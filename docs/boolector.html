

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Module Index: pyboolector &mdash; Boolector 3.2.2 documentation</title>
  

  
  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="static/documentation_options.js"></script>
        <script src="static/jquery.js"></script>
        <script src="static/underscore.js"></script>
        <script src="static/doctools.js"></script>
    
    <script type="text/javascript" src="static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Boolector Options" href="pyboolector_options.html" />
    <link rel="prev" title="Boolector Python API documentation" href="pyboolector.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Boolector
          

          
          </a>

          
            
            
              <div class="version">
                3.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="cboolector.html">Boolector C API documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pyboolector.html">Boolector Python API documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="pyboolector.html#interface">Interface</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Python interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="pyboolector_options.html">Boolector Options</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pyboolector.html#quickstart">Quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyboolector.html#options">Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyboolector.html#internals">Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyboolector.html#examples">Examples</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Boolector</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="pyboolector.html">Boolector Python API documentation</a> &raquo;</li>
        
      <li>Module Index: pyboolector</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-index-pyboolector">
<h1>Module Index: pyboolector<a class="headerlink" href="#module-index-pyboolector" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="pyboolector.Boolector">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyboolector.</span></span><span class="sig-name descname"><span class="pre">Boolector</span></span><a class="headerlink" href="#pyboolector.Boolector" title="Permalink to this definition">¶</a></dt>
<dd><p>The class representing a Boolector instance.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.Boolector.UNKNOWN">
<span class="sig-name descname"><span class="pre">UNKNOWN</span></span><em class="property"> <span class="pre">=</span> <span class="pre">0</span></em><a class="headerlink" href="#pyboolector.Boolector.UNKNOWN" title="Permalink to this definition">¶</a></dt>
<dd><p>Value representing an ‘unknown’ result of a call to
<a class="reference internal" href="#pyboolector.Boolector.Sat" title="pyboolector.Boolector.Sat"><code class="xref py py-func docutils literal notranslate"><span class="pre">Sat()</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.Boolector.SAT">
<span class="sig-name descname"><span class="pre">SAT</span></span><em class="property"> <span class="pre">=</span> <span class="pre">10</span></em><a class="headerlink" href="#pyboolector.Boolector.SAT" title="Permalink to this definition">¶</a></dt>
<dd><p>Value representing a ‘sat’ result of a call to
<a class="reference internal" href="#pyboolector.Boolector.Sat" title="pyboolector.Boolector.Sat"><code class="xref py py-func docutils literal notranslate"><span class="pre">Sat()</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.Boolector.UNSAT">
<span class="sig-name descname"><span class="pre">UNSAT</span></span><em class="property"> <span class="pre">=</span> <span class="pre">20</span></em><a class="headerlink" href="#pyboolector.Boolector.UNSAT" title="Permalink to this definition">¶</a></dt>
<dd><p>Value representing an ‘unsat’ result of a call to
<a class="reference internal" href="#pyboolector.Boolector.Sat" title="pyboolector.Boolector.Sat"><code class="xref py py-func docutils literal notranslate"><span class="pre">Sat()</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.Boolector.PARSE_ERROR">
<span class="sig-name descname"><span class="pre">PARSE_ERROR</span></span><em class="property"> <span class="pre">=</span> <span class="pre">1</span></em><a class="headerlink" href="#pyboolector.Boolector.PARSE_ERROR" title="Permalink to this definition">¶</a></dt>
<dd><p>Value representing a ‘parse error’ result of a call to
<a class="reference internal" href="#pyboolector.Boolector.Sat" title="pyboolector.Boolector.Sat"><code class="xref py py-func docutils literal notranslate"><span class="pre">Sat()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Add">
<span class="sig-name descname"><span class="pre">Add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Add" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector addition.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create an addition as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bvadd</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.And">
<span class="sig-name descname"><span class="pre">And</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.And" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector <em>and</em>.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create an <em>and</em> as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bvand</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Apply">
<span class="sig-name descname"><span class="pre">Apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fun</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a function application on function <code class="docutils literal notranslate"><span class="pre">fun</span></code> with arguments
<code class="docutils literal notranslate"><span class="pre">args</span></code> (see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create a function application as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">app</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">arg_0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">arg_n</span><span class="p">)</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#pyboolector.Boolector.Fun" title="pyboolector.Boolector.Fun"><code class="xref py py-func docutils literal notranslate"><span class="pre">Fun()</span></code></a>,
<a class="reference internal" href="#pyboolector.Boolector.UF" title="pyboolector.Boolector.UF"><code class="xref py py-func docutils literal notranslate"><span class="pre">UF()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a>) – A list of arguments to be applied.</p></li>
<li><p><strong>fun</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Function to apply arguments <code class="docutils literal notranslate"><span class="pre">args</span></code> to.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A function application on function <code class="docutils literal notranslate"><span class="pre">fun</span></code> with arguments <code class="docutils literal notranslate"><span class="pre">args</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Array">
<span class="sig-name descname"><span class="pre">Array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sort</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a one-dimensional bit vector array variable of sort
<code class="docutils literal notranslate"><span class="pre">sort</span></code> with symbol <code class="docutils literal notranslate"><span class="pre">symbol</span></code>.</p>
<p>An array variable’s symbol is used as a simple means of
identfication, either when printing a model via
<a class="reference internal" href="#pyboolector.Boolector.Print_model" title="pyboolector.Boolector.Print_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">Print_model()</span></code></a>,
or generating file dumps via
<a class="reference internal" href="#pyboolector.Boolector.Dump" title="pyboolector.Boolector.Dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">Dump()</span></code></a>.
A symbol must be unique but may be None in case that no
symbol should be assigned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sort</strong> (<a class="reference internal" href="#pyboolector.BoolectorSort" title="pyboolector.BoolectorSort"><em>BoolectorSort</em></a>) – Sort of the array elements.</p></li>
<li><p><strong>symbol</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a>) – Symbol of the array variable.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector array variable of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code> with symbol <code class="docutils literal notranslate"><span class="pre">symbol</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In contrast to composite expressions, which are
maintained uniquely w.r.t. to their kind, inputs (and
consequently, bit width), array variables are not.
Hence, each call to this function returns a fresh bit vector
array variable.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.ArraySort">
<span class="sig-name descname"><span class="pre">ArraySort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elem</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.ArraySort" title="Permalink to this definition">¶</a></dt>
<dd><p>Create array sort.</p>
<p>See <a class="reference internal" href="#pyboolector.Boolector.Array" title="pyboolector.Boolector.Array"><code class="xref py py-func docutils literal notranslate"><span class="pre">Array()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> – The sort of the array index.</p></li>
<li><p><strong>elem</strong> (<a class="reference internal" href="#pyboolector.BoolectorSort" title="pyboolector.BoolectorSort"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorSort</span></code></a>) – The sort of the array elements.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Array sort.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorSort" title="pyboolector.BoolectorSort"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorSort</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Assert">
<span class="sig-name descname"><span class="pre">Assert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">...</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Assert" title="Permalink to this definition">¶</a></dt>
<dd><p>Add one or more constraints.</p>
<p>Added constraints can not be removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Bit vector expression with bit width 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Assume">
<span class="sig-name descname"><span class="pre">Assume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">...</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Assume" title="Permalink to this definition">¶</a></dt>
<dd><p>Add one or more assumptions.</p>
<p>You must enable Boolector’s incremental usage via
<a class="reference internal" href="#pyboolector.Boolector.Set_opt" title="pyboolector.Boolector.Set_opt"><code class="xref py py-func docutils literal notranslate"><span class="pre">Set_opt()</span></code></a> before you can add
assumptions.
In contrast to assertions added via
<a class="reference internal" href="#pyboolector.Boolector.Assert" title="pyboolector.Boolector.Assert"><code class="xref py py-func docutils literal notranslate"><span class="pre">Assert()</span></code></a>, assumptions
are discarded after each call to <a class="reference internal" href="#pyboolector.Boolector.Sat" title="pyboolector.Boolector.Sat"><code class="xref py py-func docutils literal notranslate"><span class="pre">Sat()</span></code></a>.
Assumptions and assertions are logicall combined via Boolean
<em>and</em>.
Assumption handling in Boolector is analogous to assumptions
in MiniSAT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Bit vector expression with bit width 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.BitVecSort">
<span class="sig-name descname"><span class="pre">BitVecSort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.BitVecSort" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit vector sort of bit width <code class="docutils literal notranslate"><span class="pre">width</span></code>.</p>
<p>See <a class="reference internal" href="#pyboolector.Boolector.UF" title="pyboolector.Boolector.UF"><code class="xref py py-func docutils literal notranslate"><span class="pre">UF()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>width</strong> (<em>uint32_t</em>) – Bit width.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit vector sort of bit width <code class="docutils literal notranslate"><span class="pre">width</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorSort" title="pyboolector.BoolectorSort"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorSort</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.BoolSort">
<span class="sig-name descname"><span class="pre">BoolSort</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.BoolSort" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Boolean sort.</p>
<p>Currently, sorts in Boolector are used for uninterpreted functions,
only.</p>
<p>See <a class="reference internal" href="#pyboolector.Boolector.UF" title="pyboolector.Boolector.UF"><code class="xref py py-func docutils literal notranslate"><span class="pre">UF()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Sort of type Boolean.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyboolector.BoolectorSort" title="pyboolector.BoolectorSort"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorSort</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Clone">
<span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone an instance of Boolector.</p>
<p>The resulting Boolector instance is an exact (but disjunct) copy of
its parent instance.  Consequently, in a clone and its parent,
nodes with the same id correspond to each other.  Use
<a class="reference internal" href="#pyboolector.Boolector.Match" title="pyboolector.Boolector.Match"><code class="xref py py-func docutils literal notranslate"><span class="pre">Match()</span></code></a> to match corresponding nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The exact (but disjunct) copy of a Boolector instance.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyboolector.Boolector" title="pyboolector.Boolector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Boolector</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If Lingeling is used as SAT solver, Boolector can be cloned at
any time, since Lingeling also supports cloning. However, if
you use <a class="reference internal" href="#pyboolector.Boolector.Clone" title="pyboolector.Boolector.Clone"><code class="xref py py-func docutils literal notranslate"><span class="pre">Clone()</span></code></a> with MiniSAT or
PicoSAT (no cloning suppport), Boolector can only be cloned
prior to the first <a class="reference internal" href="#pyboolector.Boolector.Sat" title="pyboolector.Boolector.Sat"><code class="xref py py-func docutils literal notranslate"><span class="pre">Sat()</span></code></a> call.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Concat">
<span class="sig-name descname"><span class="pre">Concat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the concatenation of two bit vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bitwidth <code class="docutils literal notranslate"><span class="pre">bit</span> <span class="pre">width</span> <span class="pre">of</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">bit</span> <span class="pre">width</span> <span class="pre">of</span> <span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Cond">
<span class="sig-name descname"><span class="pre">Cond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cond</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Cond" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an if-then-else.</p>
<p>If condition <code class="docutils literal notranslate"><span class="pre">cond</span></code> is true, then <code class="docutils literal notranslate"><span class="pre">a</span></code> is returned, else <code class="docutils literal notranslate"><span class="pre">b</span></code>
is returned.
<code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must be either both arrays or both bit
vectors (see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cond</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Bit vector condition with bit width one.</p></li>
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Array or bit vector operand representing the <em>then</em> case.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Array or bit vector operand representing the <em>else</em> case.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Either <code class="docutils literal notranslate"><span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Const">
<span class="sig-name descname"><span class="pre">Const</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Const" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector constant of value <code class="docutils literal notranslate"><span class="pre">c</span></code> and bit width <code class="docutils literal notranslate"><span class="pre">width</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>c</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3.9/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a>) – Value of the constant.</p></li>
<li><p><strong>width</strong> (<em>uint32_t</em>) – Bit width of the constant.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector constant of value <code class="docutils literal notranslate"><span class="pre">c</span></code> and bit width <code class="docutils literal notranslate"><span class="pre">width</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Parameter <code class="docutils literal notranslate"><span class="pre">width</span></code> is only required if <code class="docutils literal notranslate"><span class="pre">c</span></code> is an integer.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.ConstArray">
<span class="sig-name descname"><span class="pre">ConstArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sort</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.ConstArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a one-dimensional constant bit-vector array with sort
<code class="docutils literal notranslate"><span class="pre">sort</span></code> initialized with value <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Array sort which maps bit-vectors to bit-vectors.</p></li>
<li><p><strong>value</strong> – Value to initialize array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Constant bit-vector array of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyboolector.Boolector.Array" title="pyboolector.Boolector.Array"><code class="xref py py-func docutils literal notranslate"><span class="pre">Array()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Copyright">
<span class="sig-name descname"><span class="pre">Copyright</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Copyright" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The copyright information.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#str" title="(in Python v3.9)">str</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Dec">
<span class="sig-name descname"><span class="pre">Dec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Dec" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector expression that decrements bit vector <code class="docutils literal notranslate"><span class="pre">n</span></code>
by one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – A bit vector node.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector with the same bit width as <code class="docutils literal notranslate"><span class="pre">n</span></code>, decremented by one.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Dump">
<span class="sig-name descname"><span class="pre">Dump</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'btor'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump input formula to output file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>format</strong> (<em>str.</em>) – A file format identifier string (use ‘btor’ for <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a>, ‘smt2’ for <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a>, ‘aig’ for binary AIGER (QF_BV only), and ‘aag’ for ASCII AIGER (QF_BV only)).</p></li>
<li><p><strong>outile</strong> – Output file name (default: stdout).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Eq">
<span class="sig-name descname"><span class="pre">Eq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector or array equality.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are either bit vectors with the same bit
width, or arrays of the same type (see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create an equality as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">eq</span> <span class="o">=</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Exists">
<span class="sig-name descname"><span class="pre">Exists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an existentially quantified formula.</p>
<p>See <a class="reference internal" href="#pyboolector.Boolector.Param" title="pyboolector.Boolector.Param"><code class="xref py py-func docutils literal notranslate"><span class="pre">Param()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a>) – A list of (existentially quantified) parameters.</p></li>
<li><p><strong>body</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Formula existentially quantified over <code class="docutils literal notranslate"><span class="pre">params</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A formula <code class="docutils literal notranslate"><span class="pre">body</span></code> existentially quantified over <code class="docutils literal notranslate"><span class="pre">params</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Failed">
<span class="sig-name descname"><span class="pre">Failed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">...</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Failed" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if any of the given assumptions are failed assumptions.</p>
<p>Failed assumptions are those assumptions, that force an
input formula to become unsatisfiable.
Failed assumptions handling in Boolector is analogous to
failed assumptions in MiniSAT.</p>
<p>See <a class="reference internal" href="#pyboolector.Boolector.Assume" title="pyboolector.Boolector.Assume"><code class="xref py py-func docutils literal notranslate"><span class="pre">Assume()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Bit vector expression with bit width 1.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of boolean values, where True indicates that the assumption at given index is failed, and false otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#list" title="(in Python v3.9)">list</a>(<a class="reference external" href="https://docs.python.org/3.9/library/functions.html#bool" title="(in Python v3.9)">bool</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Fixate_assumptions">
<span class="sig-name descname"><span class="pre">Fixate_assumptions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Fixate_assumptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Add all assumptions added since the last
<a class="reference internal" href="#pyboolector.Boolector.Sat" title="pyboolector.Boolector.Sat"><code class="xref py py-func docutils literal notranslate"><span class="pre">Sat()</span></code></a> call as assertions.</p>
<p>See <a class="reference internal" href="#pyboolector.Boolector.Assume" title="pyboolector.Boolector.Assume"><code class="xref py py-func docutils literal notranslate"><span class="pre">Assume()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Forall">
<span class="sig-name descname"><span class="pre">Forall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Forall" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an universally quantified formula.</p>
<p>See <a class="reference internal" href="#pyboolector.Boolector.Param" title="pyboolector.Boolector.Param"><code class="xref py py-func docutils literal notranslate"><span class="pre">Param()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a>) – A list of (universally quantified) parameters.</p></li>
<li><p><strong>body</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Formula universally quantified over <code class="docutils literal notranslate"><span class="pre">params</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A formula <code class="docutils literal notranslate"><span class="pre">body</span></code> universally quantified over <code class="docutils literal notranslate"><span class="pre">params</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Fun">
<span class="sig-name descname"><span class="pre">Fun</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a function with function body <code class="docutils literal notranslate"><span class="pre">body</span></code>, parameterized
over <code class="docutils literal notranslate"><span class="pre">params</span></code>.</p>
<p>This kind of node is similar to macros in the <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a>
standard.</p>
<p>See <a class="reference internal" href="#pyboolector.Boolector.Param" title="pyboolector.Boolector.Param"><code class="xref py py-func docutils literal notranslate"><span class="pre">Param()</span></code></a>,
<a class="reference internal" href="#pyboolector.Boolector.Apply" title="pyboolector.Boolector.Apply"><code class="xref py py-func docutils literal notranslate"><span class="pre">Apply()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a>) – A list of function parameters.</p></li>
<li><p><strong>body</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Function body parameterized over <code class="docutils literal notranslate"><span class="pre">params</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A function over parameterized expression <code class="docutils literal notranslate"><span class="pre">body</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As soon as a parameter is bound to a function, it can
not be reused in other functions.
Call a function via <a class="reference internal" href="#pyboolector.Boolector.Apply" title="pyboolector.Boolector.Apply"><code class="xref py py-func docutils literal notranslate"><span class="pre">Apply()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.FunSort">
<span class="sig-name descname"><span class="pre">FunSort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">codomain</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.FunSort" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function sort.</p>
<p>See <a class="reference internal" href="#pyboolector.Boolector.UF" title="pyboolector.Boolector.UF"><code class="xref py py-func docutils literal notranslate"><span class="pre">UF()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a>) – A list of all the function arguments’ sorts.</p></li>
<li><p><strong>codomain</strong> (<a class="reference internal" href="#pyboolector.BoolectorSort" title="pyboolector.BoolectorSort"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorSort</span></code></a>) – The sort of the function’s return value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Function sort, which maps <code class="docutils literal notranslate"><span class="pre">domain</span></code> to <code class="docutils literal notranslate"><span class="pre">codomain</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorSort" title="pyboolector.BoolectorSort"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorSort</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Get_opt">
<span class="sig-name descname"><span class="pre">Get_opt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Get_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Boolector option with name <code class="docutils literal notranslate"><span class="pre">opt</span></code>.</p>
<p>For a list of all available options, see
<a class="reference internal" href="#pyboolector.Boolector.Set_opt" title="pyboolector.Boolector.Set_opt"><code class="xref py py-func docutils literal notranslate"><span class="pre">Set_opt()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>opt</strong> (<em>int32_t</em>) – Option identifier.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Option with name <code class="docutils literal notranslate"><span class="pre">opt</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorOpt" title="pyboolector.BoolectorOpt"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorOpt</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.GitId">
<span class="sig-name descname"><span class="pre">GitId</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.GitId" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The git commit sha.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#str" title="(in Python v3.9)">str</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Iff">
<span class="sig-name descname"><span class="pre">Iff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Iff" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Boolean equivalence.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have bit width one
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean equivalence <code class="docutils literal notranslate"><span class="pre">a</span></code> &lt;=&gt; <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Implies">
<span class="sig-name descname"><span class="pre">Implies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Implies" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Boolean implication.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have bit width one
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Bit vector node representing the premise.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Bit vector node representing the conclusion.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean implication <code class="docutils literal notranslate"><span class="pre">a</span></code> =&gt; <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Inc">
<span class="sig-name descname"><span class="pre">Inc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Inc" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector expression that increments bit vector <code class="docutils literal notranslate"><span class="pre">n</span></code>
by one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – A bit vector node.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector with the same bit width as <code class="docutils literal notranslate"><span class="pre">n</span></code>, incremented by one.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Match">
<span class="sig-name descname"><span class="pre">Match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Match" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the node matching given node <code class="docutils literal notranslate"><span class="pre">n</span></code> by id.</p>
<p>This is intended to be used for handling expressions of a
cloned instance (see <a class="reference internal" href="#pyboolector.Boolector.Clone" title="pyboolector.Boolector.Clone"><code class="xref py py-func docutils literal notranslate"><span class="pre">Clone()</span></code></a>).</p>
<p>E.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">btor</span> <span class="o">=</span> <span class="n">Boolector</span><span class="p">()</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">btor</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span><span class="n">btor</span><span class="o">.</span><span class="n">BitVecSort</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="n">clone</span> <span class="o">=</span> <span class="n">btor</span><span class="o">.</span><span class="n">Clone</span><span class="p">()</span>
<span class="n">v_cloned</span> <span class="o">=</span> <span class="n">clone</span><span class="o">.</span><span class="n">Match</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Boolector node.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Boolector node that matches given node <code class="docutils literal notranslate"><span class="pre">n</span></code> by id.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only nodes created before the
<a class="reference internal" href="#pyboolector.Boolector.Clone" title="pyboolector.Boolector.Clone"><code class="xref py py-func docutils literal notranslate"><span class="pre">Clone()</span></code></a> call can be matched.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Match_by_symbol">
<span class="sig-name descname"><span class="pre">Match_by_symbol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Match_by_symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the node matching symbol <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
<p>E.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">btor</span> <span class="o">=</span> <span class="n">Boolector</span><span class="p">()</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">btor</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span><span class="n">btor</span><span class="o">.</span><span class="n">BitVecSort</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">btor</span><span class="o">.</span><span class="n">Match_by_symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>s</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a>) – Symbol.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Boolector node that matches by symbol <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Mul">
<span class="sig-name descname"><span class="pre">Mul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector multiplication.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create a multiplication as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bvmul</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Nand">
<span class="sig-name descname"><span class="pre">Nand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Nand" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector <em>nand</em>.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Ne">
<span class="sig-name descname"><span class="pre">Ne</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Ne" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector or array inequality.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are either bit vectors with the same bit
width, or arrays of the same type (see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create an inequality as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ne</span> <span class="o">=</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Neg">
<span class="sig-name descname"><span class="pre">Neg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Neg" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the two’s complement of bit vector node <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>It is also possible to create the two’s complement as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bvneg</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – A bit vector node.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The two’s complement of bit vector node <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Nor">
<span class="sig-name descname"><span class="pre">Nor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Nor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector <em>nor</em>.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Not">
<span class="sig-name descname"><span class="pre">Not</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Not" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the one’s complement of bit vector node <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>It is also possible to create the one’s complement as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bvnot</span> <span class="o">=</span> <span class="o">~</span><span class="n">n</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – A bit vector node.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The one’s complement of bit vector node <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Options">
<span class="sig-name descname"><span class="pre">Options</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Options" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a <a class="reference internal" href="#pyboolector.BoolectorOptions" title="pyboolector.BoolectorOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorOptions</span></code></a> iterator.</p>
<p>E.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">btor</span> <span class="o">=</span> <span class="n">Boolector</span><span class="p">()</span>
<span class="n">options</span> <span class="o">=</span> <span class="n">btor</span><span class="o">.</span><span class="n">Options</span><span class="p">()</span>
<span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
    <span class="c1"># do something</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>An iterator to iterate over all Boolector options.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyboolector.BoolectorOptions" title="pyboolector.BoolectorOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorOptions</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Or">
<span class="sig-name descname"><span class="pre">Or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Or" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector <em>or</em>.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create an <em>or</em> as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bvor</span> <span class="o">=</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Param">
<span class="sig-name descname"><span class="pre">Param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sort</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Param" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a function parameter of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
<p>This kind of node is used to create parameterized expressions,
which in turn are used to create functions.
Once a parameter is bound to a function, it cannot be reused in
other functions.</p>
<dl class="simple">
<dt>See <a class="reference internal" href="#pyboolector.Boolector.Fun" title="pyboolector.Boolector.Fun"><code class="xref py py-func docutils literal notranslate"><span class="pre">Fun()</span></code></a>,</dt><dd><p><a class="reference internal" href="#pyboolector.Boolector.Apply" title="pyboolector.Boolector.Apply"><code class="xref py py-func docutils literal notranslate"><span class="pre">Apply()</span></code></a>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sort</strong> – Sort of the function parameter.</p></li>
<li><p><strong>symbol</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a>) – Symbol of the function parameter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A function parameter of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Parse">
<span class="sig-name descname"><span class="pre">Parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">infile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input file.</p>
<p>Input file format may be either <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a>, <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a>, or
<a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a>, the file type is detected automatically.</p>
<p>E.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">btor</span> <span class="o">=</span> <span class="n">Boolector</span><span class="p">()</span>
<span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">error_msg</span><span class="p">)</span> <span class="o">=</span> <span class="n">btor</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="s2">&quot;example.btor&quot;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>infile</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a>) – Input file name.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tuple (result, status, error_msg), where return value <code class="docutils literal notranslate"><span class="pre">result</span></code> indicates an error (<a class="reference internal" href="#pyboolector.Boolector.PARSE_ERROR" title="pyboolector.Boolector.PARSE_ERROR"><code class="xref py py-data docutils literal notranslate"><span class="pre">PARSE_ERROR</span></code></a>) if any, and else denotes the satisfiability result (<a class="reference internal" href="#pyboolector.Boolector.SAT" title="pyboolector.Boolector.SAT"><code class="xref py py-data docutils literal notranslate"><span class="pre">SAT</span></code></a> or <a class="reference internal" href="#pyboolector.Boolector.UNSAT" title="pyboolector.Boolector.UNSAT"><code class="xref py py-data docutils literal notranslate"><span class="pre">UNSAT</span></code></a>) in the incremental case, and <a class="reference internal" href="#pyboolector.Boolector.UNKNOWN" title="pyboolector.Boolector.UNKNOWN"><code class="xref py py-data docutils literal notranslate"><span class="pre">UNKNOWN</span></code></a> otherwise. Return value <code class="docutils literal notranslate"><span class="pre">status</span></code> indicates a (known) status (<a class="reference internal" href="#pyboolector.Boolector.SAT" title="pyboolector.Boolector.SAT"><code class="xref py py-data docutils literal notranslate"><span class="pre">SAT</span></code></a> or <a class="reference internal" href="#pyboolector.Boolector.UNSAT" title="pyboolector.Boolector.UNSAT"><code class="xref py py-data docutils literal notranslate"><span class="pre">UNSAT</span></code></a>) as specified in the input file. In case of an error, an explanation of that error is stored in <code class="docutils literal notranslate"><span class="pre">error_msg</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Pop">
<span class="sig-name descname"><span class="pre">Pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Pop context levels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>level</strong> – Number of levels to pop.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Assumptions added via boolector_assume are not affected by
context level changes and are only valid until the next
boolector_sat call no matter at what level they were assumed.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyboolector.Boolector.Assume" title="pyboolector.Boolector.Assume"><code class="xref py py-func docutils literal notranslate"><span class="pre">Assume()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Print_model">
<span class="sig-name descname"><span class="pre">Print_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'btor'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Print_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Print model to output file.</p>
<p>Supported model formats are Boolector’s own model format (“btor”)
and <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> (“smt2”).</p>
<p>This function prints the model for all inputs to output file
<code class="docutils literal notranslate"><span class="pre">outfile</span></code>, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">btor</span><span class="o">.</span><span class="n">Print_model</span><span class="p">()</span>
</pre></div>
</div>
<p>A possible model would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span> <span class="mi">00000100</span> <span class="n">x</span>
<span class="mi">3</span> <span class="mi">00010101</span> <span class="n">y</span>
<span class="mi">4</span><span class="p">[</span><span class="mi">00</span><span class="p">]</span> <span class="mi">01</span> <span class="n">A</span>
</pre></div>
</div>
<p>which in this case prints the assignments of array variable <code class="docutils literal notranslate"><span class="pre">A</span></code>,
and bit vector variables <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.
For bit vector variables, the first column indicates the id of an
input, the second column its assignment, and the third column its
name (symbol), if any. Array variable <code class="docutils literal notranslate"><span class="pre">A</span></code>, on the other hand,
has id 4, is an array with index and element bit width of 2,
and its value at index 0 is 1.</p>
<p>The corresponding model in <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> format would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">btor</span><span class="o">.</span><span class="n">Print_model</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;smt2&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">model</span>
  <span class="p">(</span><span class="n">define</span><span class="o">-</span><span class="n">fun</span> <span class="n">x</span> <span class="p">()</span> <span class="p">(</span><span class="n">_</span> <span class="n">BitVec</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">#b00000100)</span>
  <span class="p">(</span><span class="n">define</span><span class="o">-</span><span class="n">fun</span> <span class="n">y</span> <span class="p">()</span> <span class="p">(</span><span class="n">_</span> <span class="n">BitVec</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">#b00010101)</span>
  <span class="p">(</span><span class="n">define</span><span class="o">-</span><span class="n">fun</span> <span class="n">y</span> <span class="p">(</span>
   <span class="p">(</span><span class="n">y_x0</span> <span class="p">(</span><span class="n">_</span> <span class="n">BitVec</span> <span class="mi">2</span><span class="p">)))</span>
   <span class="p">(</span><span class="n">ite</span> <span class="p">(</span><span class="o">=</span> <span class="n">y_x0</span> <span class="c1">#b00) #b01</span>
     <span class="c1">#00))</span>
<span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>format</strong> – Model output format (default: “btor”).</p></li>
<li><p><strong>outfile</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a>) – Output file name (default: stdout).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Push">
<span class="sig-name descname"><span class="pre">Push</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Push" title="Permalink to this definition">¶</a></dt>
<dd><p>Push new context levels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>level</strong> – Number of context levels to create.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Assumptions added via boolector_assume are not affected by
context level changes and are only valid until the next
boolector_sat call no matter at what level they were assumed.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyboolector.Boolector.Assume" title="pyboolector.Boolector.Assume"><code class="xref py py-func docutils literal notranslate"><span class="pre">Assume()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Read">
<span class="sig-name descname"><span class="pre">Read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Read" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a read on array <code class="docutils literal notranslate"><span class="pre">a</span></code> at position <code class="docutils literal notranslate"><span class="pre">b</span></code>
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create a read as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">read</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Array operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bitwidth as the elements of array <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Redand">
<span class="sig-name descname"><span class="pre">Redand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Redand" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an <em>and</em> reduction of node <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>All bits of node <code class="docutils literal notranslate"><span class="pre">n</span></code> are combined by an Boolean <em>and</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – A bit vector node.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The <em>and</em> reduction of node <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Redor">
<span class="sig-name descname"><span class="pre">Redor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Redor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an <em>or</em> reduction of node <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>All bits of node <code class="docutils literal notranslate"><span class="pre">n</span></code> are combined by an Boolean <em>or</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – A bit vector node.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The <em>or</em> reduction of node <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Redxor">
<span class="sig-name descname"><span class="pre">Redxor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Redxor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an <em>xor</em> reduction of node <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>All bits of node <code class="docutils literal notranslate"><span class="pre">n</span></code> are combined by an Boolean <em>xor</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – A bit vector node.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The <em>xor</em> reduction of node <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Repeat">
<span class="sig-name descname"><span class="pre">Repeat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create <code class="docutils literal notranslate"><span class="pre">n</span></code> concatenations of bit vector <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Bit vector operand.</p></li>
<li><p><strong>n</strong> (<em>uint32_t</em>) – The number of times node <code class="docutils literal notranslate"><span class="pre">a</span></code> should be repeated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bitwidth <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">bit</span> <span class="pre">width</span> <span class="pre">of</span> <span class="pre">a</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Reset_assumptions">
<span class="sig-name descname"><span class="pre">Reset_assumptions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Reset_assumptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all assumptions added since the last
<a class="reference internal" href="#pyboolector.Boolector.Sat" title="pyboolector.Boolector.Sat"><code class="xref py py-func docutils literal notranslate"><span class="pre">Sat()</span></code></a> call.</p>
<p>See <a class="reference internal" href="#pyboolector.Boolector.Assume" title="pyboolector.Boolector.Assume"><code class="xref py py-func docutils literal notranslate"><span class="pre">Assume()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Rol">
<span class="sig-name descname"><span class="pre">Rol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Rol" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a rotate left.</p>
<p>Given bit vector node <code class="docutils literal notranslate"><span class="pre">b</span></code>, the value it represents is the
number of bits by which node <code class="docutils literal notranslate"><span class="pre">a</span></code> is rotated to the left
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand where the bit width is a power of two and greater than 1.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand with bit width log2 of the bit width of <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Ror">
<span class="sig-name descname"><span class="pre">Ror</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Ror" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a rotate right.</p>
<p>Given bit vector node <code class="docutils literal notranslate"><span class="pre">b</span></code>, the value it represents is the
number of bits by which node <code class="docutils literal notranslate"><span class="pre">a</span></code> is rotated to the right
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand where the bit width is a power of two and greater than 1.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand with bit width log2 of the bit width of <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Saddo">
<span class="sig-name descname"><span class="pre">Saddo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Saddo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed bit vector addition overflow detection.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one, which indicates if the addition of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> overflows in case both operands are treated as signed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Sat">
<span class="sig-name descname"><span class="pre">Sat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lod_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sat_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Sat" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve an input formula.</p>
<p>An input formula is defined by constraints added via
<a class="reference internal" href="#pyboolector.Boolector.Assert" title="pyboolector.Boolector.Assert"><code class="xref py py-func docutils literal notranslate"><span class="pre">Assert()</span></code></a>.
You can guide the search for a solution to an input formula by
making assumptions via <a class="reference internal" href="#pyboolector.Boolector.Assume" title="pyboolector.Boolector.Assume"><code class="xref py py-func docutils literal notranslate"><span class="pre">Assume()</span></code></a>.</p>
<p>If you want to call this function multiple times, you must
enable Boolector’s incremental usage mode via
<a class="reference internal" href="#pyboolector.Boolector.Set_opt" title="pyboolector.Boolector.Set_opt"><code class="xref py py-func docutils literal notranslate"><span class="pre">Set_opt()</span></code></a>.
Otherwise, this function may only be called once.</p>
<p>You can limit the search by the number of lemmas generated
(<code class="docutils literal notranslate"><span class="pre">lod_limit</span></code>) and the number of conflicts encountered by
the underlying SAT solver (<code class="docutils literal notranslate"><span class="pre">sat_limit</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lod_limit</strong> (<em>int32_t</em>) – Limit for Lemmas on Demand (-1: unlimited).</p></li>
<li><p><strong>sat_limit</strong> (<em>int32_t</em>) – Conflict limit for the SAT solver (-1: unlimited).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyboolector.Boolector.SAT" title="pyboolector.Boolector.SAT"><code class="xref py py-data docutils literal notranslate"><span class="pre">SAT</span></code></a> if the input formula is satisfiable (under possibly given assumptions), <a class="reference internal" href="#pyboolector.Boolector.UNSAT" title="pyboolector.Boolector.UNSAT"><code class="xref py py-data docutils literal notranslate"><span class="pre">UNSAT</span></code></a> if it is unsatisfiable, and <a class="reference internal" href="#pyboolector.Boolector.UNKNOWN" title="pyboolector.Boolector.UNKNOWN"><code class="xref py py-data docutils literal notranslate"><span class="pre">UNKNOWN</span></code></a> if the instance could not be solved within given limits.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Assertions and assumptions are combined via Boolean <em>and</em>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyboolector.BoolectorNode.assignment" title="pyboolector.BoolectorNode.assignment"><code class="xref py py-data docutils literal notranslate"><span class="pre">assignment</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Sdiv">
<span class="sig-name descname"><span class="pre">Sdiv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Sdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed  bit vector division.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Signed division is expressed by means of unsigned division,
where either node is normalized in case that its sign bit is 1.
If the sign bits of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> do not match, two’s
complement is performed on the result of the previous unsigned
division.  Hence, the behavior in case of a division by zero
depends on <a class="reference internal" href="#pyboolector.Boolector.Udiv" title="pyboolector.Boolector.Udiv"><code class="xref py py-func docutils literal notranslate"><span class="pre">Udiv()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Sdivo">
<span class="sig-name descname"><span class="pre">Sdivo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Sdivo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed  bit vector division overflow detection.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).
An overflow can occur if <code class="docutils literal notranslate"><span class="pre">a</span></code> represents INT_MIN and <code class="docutils literal notranslate"><span class="pre">b</span></code>
represents -1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one, which indicates if the division of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> overflows in case both operands are treated as signed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unsigned bit vector division does not overflow.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Set_opt">
<span class="sig-name descname"><span class="pre">Set_opt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Set_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>Set option.</p>
<p>E.g., given a Boolector instance <code class="docutils literal notranslate"><span class="pre">btor</span></code>, model generation is enabled via</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">btor</span><span class="o">.</span><span class="n">Set_opt</span><span class="p">(</span><span class="n">BTOR_OPT_MODEL_GEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>General Options:</strong></p>
<ul>
<li><p><strong>BTOR_OPT_MODEL_GEN</strong></p>
<div class="line-block">
<div class="line">Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1 or 2) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) generation of a
model for satisfiable instances.</div>
<div class="line">There are two modes for model generation:</div>
</div>
<ul class="simple">
<li><p>generate model for asserted expressions only (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1)</p></li>
<li><p>generate model for all expressions (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 2)</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_INCREMENTAL</strong></p>
<div class="line-block">
<div class="line">Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) incremental mode.</div>
<div class="line">Note that incremental usage turns off some optimization techniques.
Disabling incremental usage is currently not supported.</div>
</div>
</li>
<li><p><strong>BTOR_OPT_INCREMENTAL_SMT1</strong></p>
<div class="line-block">
<div class="line">Set incremental mode for SMT-LIB v1 input.</div>
</div>
<ul class="simple">
<li><p>BTOR_INCREMENTAL_SMT1_BASIC [default]:
stop after first satisfiable formula</p></li>
<li><p>BTOR_INCREMENTAL_SMT1_CONTINUE:
solve all formulas</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_INPUT_FORMAT</strong></p>
<div class="line-block">
<div class="line">Force input file format.</div>
<div class="line">If unspecified, Boolector automatically detects the input file format
while parsing.</div>
</div>
<ul class="simple">
<li><p>BTOR_INPUT_FORMAT_BTOR:
<a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a> format</p></li>
<li><p>BTOR_INPUT_FORMAT_BTOR2:
<a class="reference external" href="http://fmv.jku.at/papers/NiemetzPreinerWolfBiere-CAV18.pdf">BTOR2</a> format</p></li>
<li><p>BTOR_INPUT_FORMAT_SMT1:
<a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a> format</p></li>
<li><p>BTOR_INPUT_FORMAT_SMT2:
<a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> format</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_OUTPUT_NUMBER_FORMAT</strong></p>
<div class="line-block">
<div class="line">Force output number format.</div>
</div>
<ul class="simple">
<li><p>BTOR_OUTPUT_BASE_BIN [default]:
binary</p></li>
<li><p>BTOR_OUTPUT_BASE_HEX:
hexa-decimal</p></li>
<li><p>BTOR_OUTPUT_BASE_DEC:
decimal</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_OUTPUT_FORMAT</strong></p>
<div class="line-block">
<div class="line">Force output file format (<code class="docutils literal notranslate"><span class="pre">value</span></code>: <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a>: -1, <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a>: 1,
<a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a>: 2).</div>
</div>
<ul class="simple">
<li><p>BTOR_OUTPUT_FORMAT_BTOR [default]:
<a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a> format</p></li>
<li><p>BTOR_OUTPUT_FORMAT_BTOR2:
<a class="reference external" href="http://fmv.jku.at/papers/NiemetzPreinerWolfBiere-CAV18.pdf">BTOR2</a> format</p></li>
<li><p>BTOR_OUTPUT_FORMAT_SMT2:
<a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> format</p></li>
<li><p>BTOR_OUTPUT_FORMAT_AIGER_ASCII:
<a class="reference external" href="http://fmv.jku.at/papers/BiereHeljankoWieringa-FMV-TR-11-2.pdf">Aiger ascii format</a></p></li>
<li><p>BTOR_OUTPUT_FORMAT_AIGER_BINARY:
<a class="reference external" href="http://fmv.jku.at/papers/BiereHeljankoWieringa-FMV-TR-11-2.pdf">Aiger binary format</a></p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_ENGINE</strong></p>
<div class="line-block">
<div class="line">Set solver engine.</div>
</div>
<ul class="simple">
<li><p>BTOR_ENGINE_FUN [default]:
the default engine for all combinations of QF_AUFBV, uses lemmas on
demand for QF_AUFBV and eager bit-blasting for QF_BV</p></li>
<li><p>BTOR_ENGINE_SLS:
the score-based local search QF_BV engine</p></li>
<li><p>BTOR_ENGINE_PROP:
the propagation-based local search QF_BV engine</p></li>
<li><p>BTOR_ENGINE_AIGPROP:
the propagation-based local search QF_BV engine that operates on the
bit-blasted formula (the AIG layer)</p></li>
<li><p>BTOR_ENGINE_QUANT:
the quantifier engine (BV only)</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_SAT_ENGINE</strong></p>
<div class="line-block">
<div class="line">Set sat solver engine.</div>
<div class="line">Available option values and default values depend on the sat solvers
configured.</div>
</div>
<ul class="simple">
<li><p>BTOR_SAT_ENGINE_CADICAL:
<a class="reference external" href="https://fmv.jku.at/cadical">CaDiCaL</a></p></li>
<li><p>BTOR_SAT_ENGINE_CMS:
<a class="reference external" href="https://github.com/msoos/cryptominisat">CryptoMiniSat</a></p></li>
<li><p>BTOR_SAT_ENGINE_LINGELING:
<a class="reference external" href="https://fmv.jku.at/lingeling">Lingeling</a></p></li>
<li><p>BTOR_SAT_ENGINE_MINISAT:
<a class="reference external" href="https://github.com/niklasso/minisat">MiniSat</a></p></li>
<li><p>BTOR_SAT_ENGINE_PICOSAT:
<a class="reference external" href="http://fmv.jku.at/picosat/">PicoSAT</a></p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_AUTO_CLEANUP</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>:1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>:0) auto cleanup of all
references held on exit.</p>
</li>
<li><p><strong>BTOR_OPT_PRETTY_PRINT</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) pretty printing when
dumping.</p>
</li>
<li><p><strong>BTOR_OPT_EXIT_CODES</strong></p>
<div class="line-block">
<div class="line">Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>:1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>:0) the use of Boolector exit
codes (BOOLECTOR_SAT, BOOLECTOR_UNSAT, BOOLECTOR_UNKNOWN - see
<a class="reference internal" href="cboolector_index.html#macros"><span class="std std-ref">Macros</span></a>).</div>
<div class="line">If disabled, on exit Boolector returns 0 if success (sat or unsat), and
1 in any other case.</div>
</div>
</li>
<li><p><strong>BTOR_OPT_SEED</strong></p>
<div class="line-block">
<div class="line">Set seed for Boolector’s internal random number generator.</div>
<div class="line">Boolector uses 0 by default.</div>
</div>
</li>
</ul>
<p><strong>Simplifier Options:</strong></p>
<ul>
<li><p><strong>BTOR_OPT_REWRITE_LEVEL</strong></p>
<div class="line-block">
<div class="line">Set the rewrite level (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0-3) of the rewriting engine.</div>
<div class="line">Boolector uses rewrite level 3 by default, rewrite levels are
classified as follows:</div>
</div>
<ul class="simple">
<li><p>0: no rewriting</p></li>
<li><p>1: term level rewriting</p></li>
<li><p>2: more simplification techniques</p></li>
<li><p>3: full rewriting/simplification</p></li>
</ul>
<div class="line-block">
<div class="line">Do not alter the rewrite level of the rewriting engine after creating
expressions.</div>
</div>
</li>
<li><p><strong>BTOR_OPT_SKELETON_PREPROC</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) skeleton  preprocessing
during simplification.</p>
</li>
<li><p><strong>BTOR_OPT_ACKERMANN</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) the eager addition of
Ackermann constraints for function applications.</p>
</li>
<li><p><strong>BTOR_OPT_BETA_REDUCE</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) the eager elimination of
lambda expressions via beta reduction.</p>
</li>
<li><p><strong>BTOR_OPT_ELIMINATE_SLICES</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) slice elimination on bit
vector variables.</p>
</li>
<li><p><strong>BTOR_OPT_VAR_SUBST</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) variable substitution
during simplification.</p>
</li>
<li><p><strong>BTOR_OPT_UCOPT</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) unconstrained
optimization.</p>
</li>
<li><p><strong>BTOR_OPT_MERGE_LAMBDAS</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) merging of lambda
expressions.</p>
</li>
<li><p><strong>BTOR_OPT_EXTRACT_LAMBDAS</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) extraction of common
array patterns as lambda terms.</p>
</li>
<li><p><strong>BTOR_OPT_NORMALIZE</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) normalization of
addition, multiplication and bit-wise and.</p>
</li>
<li><p><strong>BTOR_OPT_NORMALIZE_ADD</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) normalization of
addition.</p>
</li>
</ul>
<p><strong>Fun Engine Options:</strong></p>
<ul>
<li><p><strong>BTOR_OPT_FUN_PREPROP</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) prop engine as
preprocessing step within sequential portfolio setting.</p>
</li>
<li><p><strong>BTOR_OPT_FUN_PRESLS</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) sls engine as
preprocessing step within sequential portfolio setting.</p>
</li>
<li><p><strong>BTOR_OPT_FUN_DUAL_PROP</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) dual propagation
optimization.</p>
</li>
<li><p><strong>BTOR_OPT_FUN_DUAL_PROP_QSORT</strong></p>
<div class="line-block">
<div class="line">Set order in which inputs are assumed in dual propagation clone.</div>
</div>
<ul class="simple">
<li><p>BTOR_DP_QSORT_JUST [default]:
order by score, highest score first</p></li>
<li><p>BTOR_DP_QSORT_ASC:
order by input id, ascending</p></li>
<li><p>BTOR_DP_QSORT_DESC:
order by input id, descending</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_FUN_JUST</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) justification
optimization.</p>
</li>
<li><p><strong>BTOR_OPT_FUN_JUST_HEURISTIC</strong></p>
<div class="line-block">
<div class="line">Set heuristic that determines path selection for justification
optimization.</div>
</div>
<ul class="simple">
<li><p>BTOR_JUST_HEUR_BRANCH_MIN_APP [default]:
choose branch with minimum number of applies</p></li>
<li><p>BTOR_JUST_HEUR_BRANCH_MIN_DEP:
choose branch with minimum depth</p></li>
<li><p>BTOR_JUST_HEUR_LEFT:
always choose left branch</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_FUN_LAZY_SYNTHESIZE</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) lazy synthesis of bit
vector expressions.</p>
</li>
<li><p><strong>BTOR_OPT_FUN_EAGER_LEMMAS</strong></p>
<div class="line-block">
<div class="line">Select mode for eager generation lemmas.</div>
</div>
<ul class="simple">
<li><p>BTOR_FUN_EAGER_LEMMAS_NONE:
do not generate lemmas eagerly (generate one single lemma per
refinement iteration)</p></li>
<li><p>BTOR_FUN_EAGER_LEMMAS_CONF:
only generate lemmas eagerly until the first conflict dependent on
another conflict is found</p></li>
<li><p>BTOR_FUN_EAGER_LEMMAS_ALL:
in each refinement iteration, generate lemmas for all conflicts</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_PRINT_DIMACS</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) DIMACS printer.</p>
<p>When enabled Boolector will record the CNF sent to the SAT solver and
prints it to stdout.</p>
</li>
</ul>
<p><strong>SLS Engine Options:</strong></p>
<ul>
<li><p><strong>BTOR_OPT_SLS_NFIPS</strong>
Set the number of bit flips used as a limit for the sls engine. Disabled
if 0.</p></li>
<li><p><strong>BTOR_OPT_SLS_STRATEGY</strong></p>
<div class="line-block">
<div class="line">Select move strategy for SLS engine.</div>
</div>
<ul class="simple">
<li><p>BTOR_SLS_STRAT_BEST_MOVE:
always choose best score improving move</p></li>
<li><p>BTOR_SLS_STRAT_RAND_WALK:
always choose random walk weighted by score</p></li>
<li><p>BTOR_SLS_STRAT_FIRST_BEST_MOVE [default]:
always choose first best move (no matter if any other move is better)</p></li>
<li><p>BTOR_SLS_STRAT_BEST_SAME_MOVE:
determine move as best move even if its score is not better but the
same as the score of the previous best move</p></li>
<li><p>BTOR_SLS_STRAT_ALWAYS_PROP:
always choose propagation move (and recover with SLS move in case of
conflict)</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_SLS_JUST</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) justification based path
selection during candidate selection.</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_GW</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) group-wise moves, where
rather than changing the assignment of one single candidate variable, all
candidate variables are set at the same time (using the same strategy).</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_RANGE</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) range-wise bit-flip
moves, where the bits within all ranges from 2 to the bit width (starting
from the LSB) are flipped at once.</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_SEGMENT</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) segment-wise bit-flip
moves, where the bits within segments of multiples of 2 are flipped at
once.</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_RAND_WALK</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) random walk moves, where
one out of all possible neighbors is randomly selected (with given
probability, see BTOR_OPT_SLS_PROB_MOVE_RAND_WALK) for a randomly
selected candidate variable.</p>
</li>
<li><p><strong>BTOR_OPT_SLS_PROB_MOVE_RAND_WALK</strong></p>
<p>Set the probability with which a random walk is chosen if random walks
are enabled (see BTOR_OPT_SLS_MOVE_RAND_WALK).</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_RAND_ALL</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) the randomization of all
candidate variables (rather than a single randomly selected candidate
variable) in case no best move has been found.</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_RAND_RANGE</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) the randomization of bit
ranges (rather than all bits) of a candidate variable(s) to be randomized
in case no best move has been found.</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_PROP</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) propagation moves (chosen
with a given ratio of number of propagation moves to number of regular
SLS moves, see BTOR_OPT_SLS_MOVE_PROP_N_PROP and
BTOR_OPT_SLS_MOVE_PROP_N_SLS).</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_PROP_N_PROP</strong></p>
<p>Set the number of propagation moves to be performed when propagation
moves are enabled (propagation moves are chosen with a ratio of
propagation moves to regular SLS moves, see BTOR_OPT_SLS_MOVE_PROP and
BTOR_OPT_SLS_MOVE_PROP_N_SLS).</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_PROP_N_SLS</strong></p>
<p>Set the number of regular SLS moves to be performed when propagation
moves are enabled (propagation moves are chosen with a ratio of
propagation moves to regular SLS moves, see BTOR_OPT_SLS_MOVE_PROP and
BTOR_OPT_SLS_MOVE_PROP_N_PROP).</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_PROP_FORCE_RW</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) that random walks are
forcibly chosen as recovery moves in case of conflicts when a propagation
move is performed (rather than performing a regular SLS move).</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_INC_MOVE_TEST</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) that during best move
selection, if the current candidate variable with a previous neighbor
yields the currently best score, this neighbor assignment is used as a
base for further neighborhood exploration (rather than its current
assignment).</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_RESTARTS</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) restarts.</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_RESTARTS</strong></p>
<div class="line-block">
<div class="line">Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) heuristic (bandit
scheme) for selecting root constraints.</div>
<div class="line">If disabled, candidate root constraints are selected randomly.</div>
</div>
</li>
</ul>
<p><strong>Prop Engine Options</strong>:</p>
<ul>
<li><p><strong>BTOR_OPT_PROP_NPROPS</strong></p>
<p>Set the number of propagation (steps) used as a limit for the propagation
engine. Disabled if 0.</p>
</li>
<li><p><strong>BTOR_OPT_PROP_USE_RESTARTS</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) restarts.</p>
</li>
<li><p><strong>BTOR_OPT_PROP_USE_RESTARTS</strong></p>
<div class="line-block">
<div class="line">Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) heuristic (bandit
scheme) for selecting root constraints.</div>
<div class="line">If enabled, root constraint selection via bandit scheme is based on a
scoring scheme similar to the one employed in the SLS engine.</div>
<div class="line">If disabled, candidate root constraints are selected randomly.</div>
</div>
</li>
<li><p><strong>BTOR_OPT_PROP_PATH_SEL</strong></p>
<p>Select mode for path selection.</p>
<ul class="simple">
<li><p>BTOR_PROP_PATH_SEL_CONTROLLING:
select path based on controlling inputs</p></li>
<li><p>BTOR_PROP_PATH_SEL_ESSENTIAL [default]:
select path based on essential inputs</p></li>
<li><p>BTOR_PROP_PATH_SEL_RANDOM:
select path based on random inputs</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_PROP_PROB_USE_INV_VALUE</strong></p></li>
</ul>
<blockquote>
<div><p>Set probabiality with which to choose inverse values over consistent
values.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>BTOR_OPT_PROP_PROB_FLIP_COND</strong></p></li>
</ul>
<blockquote>
<div><p>Set probability with which to select the path to the condition (in case of
an if-then-else operation) rather than the enabled branch during down
propagation.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>BTOR_OPT_PROP_PROB_FLIP_COND_CONST</strong></p></li>
</ul>
<blockquote>
<div><p>Set probbiality with which to select the path to the condition (in case of
an if-then-else operation) rather than the enabled branch during down
propagation if either of the ‘then’ or ‘else’ branch is constant.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>BTOR_OPT_PROP_FLIP_COND_CONST_DELTA</strong></p></li>
</ul>
<blockquote>
<div><p>Set delta by which BTOR_OPT_PROP_PROB_FLIP_COND_CONST is decreased or
increased after a limit BTOR_OPT_PROP_FLIP_COND_CONST_NPATHSEL is reached.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>BTOR_OPT_PROP_FLIP_COND_CONST_NPATHSEL</strong></p></li>
</ul>
<blockquote>
<div><p>Set the limit for how often the path to the condition (in case of an
if-then-else operation) may be selected bevor
BTOR_OPT_PROP_PROB_FLIP_COND_CONST is decreased or increased by
BTOR_OPT_PROP_PROB_FLIP_COND_CONST_DELTA.</p>
</div></blockquote>
<ul>
<li><p><strong>BTOR_OPT_PROP_PROB_SLICE_KEEP_DC</strong></p>
<p>Set probability with which to keep the current value of the don’t care
bits of a slice operation (rather than fully randomizing all of them)
when selecting an inverse or consistent value.</p>
</li>
<li><p><strong>BTOR_OPT_PROP_PROB_CONC_FLIP</strong></p></li>
</ul>
<blockquote>
<div><p>Set probability with which to use the corresponing slice of current
assignment with max. one of its bits flipped (rather than using the
corresponding slice of the down propagated assignment) as result of
consistent value selection for concats.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>BTOR_OPT_PROP_PROB_SLICE_FLIP</strong></p></li>
</ul>
<blockquote>
<div><p>Set probability with which to use the current assignment of the operand of
a slice operation with one of the don’t care bits flipped (rather than
fully randomizing all of them, both for inverse and consistent value
selection) if their current assignment is not kept (see
BTOR_OPT_PROP_PROB_SLICE_KEEP_DC).</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>BTOR_OPT_PROP_PROB_EQ_FLIP</strong></p></li>
</ul>
<blockquote>
<div><p>Set probability with which the current assignment of the selected node
with one of its bits flipped (rather than a fully randomized bit-vector)
is down-propagated in case of an inequality (both for inverse and
consistent value selection).</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>BTOR_OPT_PROP_PROB_AND_FLIP</strong></p></li>
</ul>
<blockquote>
<div><p>Set probability with which the current assignment of the don’t care bits
of the selected node with max. one of its bits flipped (rather than fully
randomizing all of them) in case of an and operation (for both inverse and
consistent value selection).</p>
</div></blockquote>
<ul>
<li><p><strong>BTOR_OPT_PROP_NO_MOVE_ON_CONFLICT</strong></p>
<div class="line-block">
<div class="line">Do not perform a propagation move when running into a conflict during
inverse computation.</div>
<div class="line">(This is the default behavior for the SLS engine when propagation moves
are enabled, where a conflict triggers a recovery by means of a regular
SLS move.)</div>
</div>
</li>
</ul>
<p><strong>AIGProp Engine Options</strong>:</p>
<ul>
<li><p><strong>BTOR_OPT_AIGPROP_USE_RESTARTS</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) restarts.</p>
</li>
<li><p><strong>BTOR_OPT_AIGPROP_USE_RESTARTS</strong></p>
<div class="line-block">
<div class="line">Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) heuristic (bandit
scheme) for selecting root constraints.</div>
<div class="line">If enabled, root constraint selection via bandit scheme is based on a
scoring scheme similar to the one employed in the SLS engine.</div>
<div class="line">If disabled, candidate root constraints are selected randomly.</div>
</div>
</li>
<li><p><strong>BTOR_OPT_QUANT_SYNTH</strong></p></li>
</ul>
<blockquote>
<div><p>Select synthesis mode for Skolem functions.</p>
<ul class="simple">
<li><p>BTOR_QUANT_SYNTH_NONE:
do not synthesize skolem functions (use model values for instantiation)</p></li>
<li><p>BTOR_QUANT_SYNTH_EL:
use enumerative learning to synthesize skolem functions</p></li>
<li><p>BTOR_QUANT_SYNTH_ELMC:
use enumerative learning modulo the predicates in the cone of influence
of the existential variables to synthesize skolem functions</p></li>
<li><p>BTOR_QUANT_SYNTH_EL_ELMC:
chain BTOR_QUANT_SYNTH_EL and BTOR_QUANT_SYNTH_ELMC approaches to
synthesize skolem functions</p></li>
<li><p>BTOR_QUANT_SYNTH_ELMR:
use enumerative learning modulo the given root constraints to synthesize
skolem functions</p></li>
</ul>
</div></blockquote>
<ul>
<li><p><strong>BTOR_OPT_QUANT_DUAL_SOLVER</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) solving the dual
(negated) version of the quantified bit-vector formula.</p>
</li>
<li><p><strong>BTOR_OPT_QUANT_SYNTH_LIMIT</strong></p>
<p>Set the limit of enumerated expressions for the enumerative learning
synthesis algorithm.</p>
</li>
<li><p><strong>BTOR_OPT_SYNTH_QI</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) generalization of
quantifier instantiations via enumerative learning.</p>
</li>
<li><p><strong>BTOR_OPT_QUANT_DER</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) destructive equality
resolution simplification.</p>
</li>
<li><p><strong>BTOR_OPT_QUANT_CER</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) constructive equality
resolution simplification.</p>
</li>
<li><p><strong>BTOR_OPT_QUANT_MINISCOPE</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) miniscoping.</p>
</li>
</ul>
<div class="toctree-wrapper compound">
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>opt</strong> (<em>int32_t</em>) – Option identifier.</p></li>
<li><p><strong>value</strong> (<em>uint32_t</em>) – Option value.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Set_sat_solver">
<span class="sig-name descname"><span class="pre">Set_sat_solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clone</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Set_sat_solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the SAT solver to use.</p>
<p>E.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">btor</span> <span class="o">=</span> <span class="n">Boolector</span><span class="p">()</span>
<span class="n">btor</span><span class="o">.</span><span class="n">Set_sat_solver</span><span class="p">(</span><span class="s2">&quot;MiniSAT&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Option <code class="docutils literal notranslate"><span class="pre">clone</span></code> enables non-incremental SAT solver usage
(for every SAT call) by means of internal SAT solver cloning.
Use this option with caution (might have a positive or negative
impact on overall performance).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>solver</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a>) – Solver identifier string.</p></li>
<li><p><strong>clone</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a>) – Force non-incremental SAT solver usage.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Parameter <code class="docutils literal notranslate"><span class="pre">clone</span></code> is currently only supported by Lingeling.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Set_term">
<span class="sig-name descname"><span class="pre">Set_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fun</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Set_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a termination callback function.</p>
<p>Use this function to force Boolector to prematurely terminate if
callback function <code class="docutils literal notranslate"><span class="pre">fun</span></code> returns True. Arguments <code class="docutils literal notranslate"><span class="pre">args</span></code> to
<code class="docutils literal notranslate"><span class="pre">fun</span></code> may be passed as a single Python object (in case that
<code class="docutils literal notranslate"><span class="pre">fun</span></code> takes only one argument), a tuple, or a list of arguments.</p>
<p>E.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">fun1</span> <span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="c1"># timeout after 1 sec.</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">arg</span> <span class="o">&gt;</span> <span class="mf">1.0</span>

<span class="k">def</span> <span class="nf">fun2</span> <span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">):</span>
    <span class="c1"># do something and return True/False</span>
    <span class="o">...</span>

<span class="n">btor</span> <span class="o">=</span> <span class="n">Boolector</span><span class="p">()</span>

<span class="n">btor</span><span class="o">.</span><span class="n">Set_term</span><span class="p">(</span><span class="n">fun1</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
<span class="n">btor</span><span class="o">.</span><span class="n">Set_term</span><span class="p">(</span><span class="n">fun1</span><span class="p">,</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),))</span>
<span class="n">btor</span><span class="o">.</span><span class="n">Set_term</span><span class="p">(</span><span class="n">fun1</span><span class="p">,</span> <span class="p">[</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>

<span class="n">btor</span><span class="o">.</span><span class="n">Set_term</span><span class="p">(</span><span class="n">fun2</span><span class="p">,</span> <span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">))</span>
<span class="n">btor</span><span class="o">.</span><span class="n">Set_term</span><span class="p">(</span><span class="n">run2</span><span class="p">,</span> <span class="p">[</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> – A python function.</p></li>
<li><p><strong>args</strong> – A function argument or a list or tuple of function arguments.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Sext">
<span class="sig-name descname"><span class="pre">Sext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Sext" title="Permalink to this definition">¶</a></dt>
<dd><p>Create signed extension.</p>
<p>Bit vector node <code class="docutils literal notranslate"><span class="pre">n</span></code> is padded with <code class="docutils literal notranslate"><span class="pre">width</span></code> bits, where the
padded value depends on the value of the most significant bit
of node <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – A bit vector node.</p></li>
<li><p><strong>width</strong> (<em>uint32_t</em>) – Number of bits to pad.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector extended by <code class="docutils literal notranslate"><span class="pre">width</span></code> bits.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Sgt">
<span class="sig-name descname"><span class="pre">Sgt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Sgt" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed greater than.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Sgte">
<span class="sig-name descname"><span class="pre">Sgte</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Sgte" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed greater than or equal.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Simplify">
<span class="sig-name descname"><span class="pre">Simplify</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplify current input formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.Boolector.SAT" title="pyboolector.Boolector.SAT"><code class="xref py py-data docutils literal notranslate"><span class="pre">SAT</span></code></a> if the input formula was simplified to true, <a class="reference internal" href="#pyboolector.Boolector.UNSAT" title="pyboolector.Boolector.UNSAT"><code class="xref py py-data docutils literal notranslate"><span class="pre">UNSAT</span></code></a> if it was simplified to false, and <a class="reference internal" href="#pyboolector.Boolector.UNKNOWN" title="pyboolector.Boolector.UNKNOWN"><code class="xref py py-data docutils literal notranslate"><span class="pre">UNKNOWN</span></code></a>, otherwise.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Each call to <a class="reference internal" href="#pyboolector.Boolector.Sat" title="pyboolector.Boolector.Sat"><code class="xref py py-func docutils literal notranslate"><span class="pre">Sat()</span></code></a>
simplifies the input formula as a preprocessing step.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Slice">
<span class="sig-name descname"><span class="pre">Slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector slice of node <code class="docutils literal notranslate"><span class="pre">n</span></code> from index <code class="docutils literal notranslate"><span class="pre">upper</span></code>
to index <code class="docutils literal notranslate"><span class="pre">lower</span></code>.</p>
<p>It is also possible to use Python slices on bit vectors as
follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n</span><span class="p">[</span><span class="n">upper</span><span class="p">:</span><span class="n">lower</span><span class="p">]</span>  <span class="c1"># creates slice with upper limit &#39;upper&#39; and lower limit &#39;lower&#39;</span>
<span class="n">n</span><span class="p">[</span><span class="n">upper</span><span class="p">:]</span>       <span class="c1"># creates slice with upper limit &#39;upper&#39; and lower limit 0</span>
<span class="n">n</span><span class="p">[:</span><span class="n">lower</span><span class="p">]</span>       <span class="c1"># creates slice with upper limit &#39;n.width - 1&#39; and lower limit &#39;lower&#39;</span>
<span class="n">n</span><span class="p">[:]</span>            <span class="c1"># creates copy of node &#39;n&#39;</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – A bit vector node.</p></li>
<li><p><strong>upper</strong> (<em>uint32_t</em>) – Upper index, which must be greater than or equal to zero, and less than the bit width of node <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></li>
<li><p><strong>lower</strong> (<em>uint32_t</em>) – Lower index, which must be greater than or equal to zero, and less than or equal to <code class="docutils literal notranslate"><span class="pre">upper</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Bit vector with bit width <code class="docutils literal notranslate"><span class="pre">upper</span></code> - <code class="docutils literal notranslate"><span class="pre">lower</span></code> + 1.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Sll">
<span class="sig-name descname"><span class="pre">Sll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Sll" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a logical shift left.</p>
<p>Given bit vector node <code class="docutils literal notranslate"><span class="pre">b</span></code>, the value it represents is the
number of zeroes shifted into node <code class="docutils literal notranslate"><span class="pre">a</span></code> from the right
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create a logical shift left as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bvshl</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand where the bit width is a power of two and greater than 1.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand with bit width log2 of the bit width of <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Slt">
<span class="sig-name descname"><span class="pre">Slt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Slt" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed less than.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Slte">
<span class="sig-name descname"><span class="pre">Slte</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Slte" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed less than or equal.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Smod">
<span class="sig-name descname"><span class="pre">Smod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Smod" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed remainder where its sign matches the sign of the
divisor.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">b</span></code> is zero, the result depends on
<a class="reference internal" href="#pyboolector.Boolector.Urem" title="pyboolector.Boolector.Urem"><code class="xref py py-func docutils literal notranslate"><span class="pre">Urem()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Smulo">
<span class="sig-name descname"><span class="pre">Smulo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Smulo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed bit vector multiplication overflow detection.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one, which indicates if the multiplication of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> overflows in case both operands are treated as signed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Sra">
<span class="sig-name descname"><span class="pre">Sra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Sra" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an arithmetic shift right.</p>
<p>Analogously to <a class="reference internal" href="#pyboolector.Boolector.Srl" title="pyboolector.Boolector.Srl"><code class="xref py py-func docutils literal notranslate"><span class="pre">Srl()</span></code></a>, but whether
zeroes or ones are shifted in depends on the most significant
bit of node <code class="docutils literal notranslate"><span class="pre">a</span></code> (see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand where the bit width is a power of two and greater than 1.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand with bit width log2 of the bit width of <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Srem">
<span class="sig-name descname"><span class="pre">Srem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Srem" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed remainder.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).
If <code class="docutils literal notranslate"><span class="pre">b</span></code> is 0, the result of the unsigned remainder is <code class="docutils literal notranslate"><span class="pre">a</span></code>.
If <code class="docutils literal notranslate"><span class="pre">b</span></code> is 0, the result of the unsigned remainder is <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>Analogously to <a class="reference internal" href="#pyboolector.Boolector.Sdiv" title="pyboolector.Boolector.Sdiv"><code class="xref py py-func docutils literal notranslate"><span class="pre">Sdiv()</span></code></a>, the signed
remainder is expressed by means of the unsigned remainder,
where either node is normalized in case that its sign bit is 1.
Hence, in case that <code class="docutils literal notranslate"><span class="pre">b</span></code> is zero, the result depends on
<a class="reference internal" href="#pyboolector.Boolector.Urem" title="pyboolector.Boolector.Urem"><code class="xref py py-func docutils literal notranslate"><span class="pre">Urem()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Srl">
<span class="sig-name descname"><span class="pre">Srl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Srl" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a logical shift right.</p>
<p>Given bit vector node <code class="docutils literal notranslate"><span class="pre">b</span></code>, the value it represents is the
number of zeroes shifted into node <code class="docutils literal notranslate"><span class="pre">a</span></code> from the left
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create a logical shift right as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bvshr</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand where the bit width is a power of two and greater than 1.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand with bit width log2 of the bit width of <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Ssubo">
<span class="sig-name descname"><span class="pre">Ssubo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Ssubo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed  bit vector subtraction overflow detection.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one, which indicates if the subtraction of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> overflows in case both operands are treated as signed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Sub">
<span class="sig-name descname"><span class="pre">Sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector subtraction.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create a subtraction as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bvsub</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Terminate">
<span class="sig-name descname"><span class="pre">Terminate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Terminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if Boolector has been terminated (and/or terminate
Boolector) via the previously configured termination callback
function.</p>
<p>See <a class="reference internal" href="#pyboolector.Boolector.Set_term" title="pyboolector.Boolector.Set_term"><code class="xref py py-func docutils literal notranslate"><span class="pre">Set_term()</span></code></a>.</p>
<p>:return True if termination condition is fulfilled, else False.
:rtype: bool</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.UF">
<span class="sig-name descname"><span class="pre">UF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sort</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.UF" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an uninterpreted function with sort <code class="docutils literal notranslate"><span class="pre">sort</span></code> and symbol
<code class="docutils literal notranslate"><span class="pre">symbol</span></code>.</p>
<p>An uninterpreted function’s symbol is used as a simple means of
identification, either when printing a model via
<a class="reference internal" href="#pyboolector.Boolector.Print_model" title="pyboolector.Boolector.Print_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">Print_model()</span></code></a>,
or generating file dumps via
<a class="reference internal" href="#pyboolector.Boolector.Dump" title="pyboolector.Boolector.Dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">Dump()</span></code></a>.
A symbol must be unique but may be None in case that no
symbol should be assigned.</p>
<p>See <a class="reference internal" href="#pyboolector.Boolector.Apply" title="pyboolector.Boolector.Apply"><code class="xref py py-func docutils literal notranslate"><span class="pre">Apply()</span></code></a>,
<a class="reference internal" href="#pyboolector.Boolector.FunSort" title="pyboolector.Boolector.FunSort"><code class="xref py py-func docutils literal notranslate"><span class="pre">FunSort()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sort</strong> (<a class="reference internal" href="#pyboolector.BoolectorSort" title="pyboolector.BoolectorSort"><em>BoolectorSort</em></a>) – Sort of the uninterpreted function.</p></li>
<li><p><strong>symbol</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a>) – Name of the uninterpreted function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A function over parameterized expression <code class="docutils literal notranslate"><span class="pre">body</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In contrast to composite expressions, which are maintained
uniquely w.r.t. to their kind, inputs (and consequently, bit
width), uninterpreted functions are not.  Hence, each
call to this function returns a fresh uninterpreted function.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Uaddo">
<span class="sig-name descname"><span class="pre">Uaddo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Uaddo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned  bit vector addition overflow detection.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one, which indicates if the addition of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> overflows in case both operands are treated as unsigned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Udiv">
<span class="sig-name descname"><span class="pre">Udiv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Udiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned  bit vector division.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).
If <code class="docutils literal notranslate"><span class="pre">b</span></code> is 0, the division’s result is -1.</p>
<p>It is also possible to create an unsigned division as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bvudiv</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This behavior (division by zero returns -1) does not exactly
comply with the SMT-LIB v1 and v2 standards, where division by
zero is handled as an uninterpreted function.  Our semantics
are motivated by real circuits where division by zero cannot be
uninterpreted and consequently returns a result.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Uext">
<span class="sig-name descname"><span class="pre">Uext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Uext" title="Permalink to this definition">¶</a></dt>
<dd><p>Create unsigned extension.</p>
<p>Bit vector node <code class="docutils literal notranslate"><span class="pre">n</span></code> is padded with <code class="docutils literal notranslate"><span class="pre">width</span></code> zeroes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – A bit vector node.</p></li>
<li><p><strong>width</strong> (<em>uint32_t</em>) – Number of zeros to pad.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector extended by <code class="docutils literal notranslate"><span class="pre">width</span></code> zeroes.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Ugt">
<span class="sig-name descname"><span class="pre">Ugt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Ugt" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned greater than.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create an unsigned greater than as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ugt</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Ugte">
<span class="sig-name descname"><span class="pre">Ugte</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Ugte" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned greater than or equal.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create an unsigned greater than or equal as
follows (see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ugte</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Ult">
<span class="sig-name descname"><span class="pre">Ult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Ult" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned less than.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create an unsigned less than as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lt</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Ulte">
<span class="sig-name descname"><span class="pre">Ulte</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Ulte" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned less than or equal.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create an unsigned less than or equal as
follows (see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lte</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Umulo">
<span class="sig-name descname"><span class="pre">Umulo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Umulo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned  bit vector multiplication overflow detection.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one, which indicates if the multiplication of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> overflows in case both operands are treated as unsigned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Urem">
<span class="sig-name descname"><span class="pre">Urem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Urem" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned remainder.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).
If <code class="docutils literal notranslate"><span class="pre">b</span></code> is 0, the result of the unsigned remainder is <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>It is also possible to create an unsigned remainder as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bvurem</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As in <a class="reference internal" href="#pyboolector.Boolector.Udiv" title="pyboolector.Boolector.Udiv"><code class="xref py py-func docutils literal notranslate"><span class="pre">Udiv()</span></code></a>, the behavior if <code class="docutils literal notranslate"><span class="pre">b</span></code>
is 0 does not exactly comply to the SMT-LIB v1 and v2 standards,
where the result ist handled as uninterpreted function.
Our semantics are motivated by real circuits, where result
can not be uninterpreted.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Usubo">
<span class="sig-name descname"><span class="pre">Usubo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Usubo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned  bit vector subtraction overflow detection.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with bit width one, which indicates if the subtraction of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> overflows in case both operands are treated as unsigned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Var">
<span class="sig-name descname"><span class="pre">Var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sort</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Var" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector variable of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
<p>A variable’s symbol is used as a simple means of identification,
either when printing a model via
<a class="reference internal" href="#pyboolector.Boolector.Print_model" title="pyboolector.Boolector.Print_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">Print_model()</span></code></a>,
or generating file dumps via
<a class="reference internal" href="#pyboolector.Boolector.Dump" title="pyboolector.Boolector.Dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">Dump()</span></code></a>.
A symbol must be unique but may be None in case that no
symbol should be assigned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sort</strong> – Sort of the variable.</p></li>
<li><p><strong>symbol</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a>) – Symbol of the variable.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector variable of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In contrast to composite expressions, which are maintained
uniquely w.r.t. to their kind, inputs (and consequently, bit
width), variables are not.  Hence, each call to this
function returns a fresh bit vector variable.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Version">
<span class="sig-name descname"><span class="pre">Version</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Version" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The version number.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#str" title="(in Python v3.9)">str</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Write">
<span class="sig-name descname"><span class="pre">Write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Write" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a write on array <code class="docutils literal notranslate"><span class="pre">array</span></code> at position <code class="docutils literal notranslate"><span class="pre">index</span></code> with value
<code class="docutils literal notranslate"><span class="pre">value</span></code> (see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>The array is updated at exactly one position, all other elements
remain unchanged.
The bit width of <code class="docutils literal notranslate"><span class="pre">index</span></code> must be the same as the bit width of
the indices of <code class="docutils literal notranslate"><span class="pre">array</span></code>.
The bit width of <code class="docutils literal notranslate"><span class="pre">value</span></code> must be the same as the bit width of
the elements of <code class="docutils literal notranslate"><span class="pre">array</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Array operand.</p></li>
<li><p><strong>index</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Bit vector index.</p></li>
<li><p><strong>value</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Bit vector value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array where the value at <code class="docutils literal notranslate"><span class="pre">index</span></code> has been updated with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Xnor">
<span class="sig-name descname"><span class="pre">Xnor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Xnor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector <em>xnor</em>.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.Boolector.Xor">
<span class="sig-name descname"><span class="pre">Xor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.Boolector.Xor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector <em>xor</em>.</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must have the same bit width
(see <a class="reference internal" href="pyboolector.html#const-conversion"><span class="std std-ref">Automatic Constant Conversion</span></a>).</p>
<p>It is also possible to create an <em>xor</em> as follows
(see <a class="reference internal" href="pyboolector.html#operator-overloading"><span class="std std-ref">Python Operator Overloading</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bvxor</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – First bit vector operand.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a>) – Second bit vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit vector node with the same bit width as <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoolectorNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyboolector.BoolectorNode">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyboolector.</span></span><span class="sig-name descname"><span class="pre">BoolectorNode</span></span><a class="headerlink" href="#pyboolector.BoolectorNode" title="Permalink to this definition">¶</a></dt>
<dd><p>The class representing a Boolector node.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.BoolectorNode.btor">
<span class="sig-name descname"><span class="pre">btor</span></span><a class="headerlink" href="#pyboolector.BoolectorNode.btor" title="Permalink to this definition">¶</a></dt>
<dd><p>The Boolector instance this node is associated with.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.BoolectorNode.Dump">
<span class="sig-name descname"><span class="pre">Dump</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'btor'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.BoolectorNode.Dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump node to output file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>format</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a>) – A file format identifier string (use ‘btor’ for <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a> and ‘smt2’ for <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a>).</p></li>
<li><p><strong>outfile</strong> (<a class="reference external" href="https://docs.python.org/3.9/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a>) – Output file name (default: stdout).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.BoolectorNode.assignment">
<span class="sig-name descname"><span class="pre">assignment</span></span><a class="headerlink" href="#pyboolector.BoolectorNode.assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>The assignment of a Boolector node.</p>
<p>May be queried only after a preceding call to
<a class="reference internal" href="#pyboolector.Boolector.Sat" title="pyboolector.Boolector.Sat"><code class="xref py py-func docutils literal notranslate"><span class="pre">Sat()</span></code></a> returned
<a class="reference internal" href="#pyboolector.Boolector.SAT" title="pyboolector.Boolector.SAT"><code class="xref py py-data docutils literal notranslate"><span class="pre">SAT</span></code></a>.</p>
<p>If the queried node is a bit vector, its assignment is
represented as string.
If it is an array, its assignment is represented as a list
of tuples <code class="docutils literal notranslate"><span class="pre">(index,</span> <span class="pre">value)</span></code>.
If it is a function, its assignment is represented as a list
of tuples <code class="docutils literal notranslate"><span class="pre">(arg_0,</span> <span class="pre">...,</span> <span class="pre">arg_n,</span> <span class="pre">value)</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.BoolectorNode.symbol">
<span class="sig-name descname"><span class="pre">symbol</span></span><a class="headerlink" href="#pyboolector.BoolectorNode.symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>The symbol of a Boolector node.</p>
<p>A node’s symbol is used as a simple means of identfication,
either when printing a model via
<a class="reference internal" href="#pyboolector.Boolector.Print_model" title="pyboolector.Boolector.Print_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">Print_model()</span></code></a>,
or generating file dumps via
<a class="reference internal" href="#pyboolector.Boolector.Dump" title="pyboolector.Boolector.Dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">Dump()</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.BoolectorNode.width">
<span class="sig-name descname"><span class="pre">width</span></span><a class="headerlink" href="#pyboolector.BoolectorNode.width" title="Permalink to this definition">¶</a></dt>
<dd><p>The bit width of a Boolector node.</p>
<p>If the node is an array,
this indicates the bit width of the array elements.
If the node is a function,
this indicates the bit with of the function’s return value.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-pyboolector"></span><p>The Python API of the SMT solver Boolector.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pyboolector.BoolectorArrayNode">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyboolector.</span></span><span class="sig-name descname"><span class="pre">BoolectorArrayNode</span></span><a class="headerlink" href="#pyboolector.BoolectorArrayNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyboolector.BoolectorNode</span></code></a></p>
<p>The class representing a Boolector array node.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.BoolectorArrayNode.index_width">
<span class="sig-name descname"><span class="pre">index_width</span></span><a class="headerlink" href="#pyboolector.BoolectorArrayNode.index_width" title="Permalink to this definition">¶</a></dt>
<dd><p>The bit with of the Boolector array node indices.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyboolector.BoolectorBVNode">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyboolector.</span></span><span class="sig-name descname"><span class="pre">BoolectorBVNode</span></span><a class="headerlink" href="#pyboolector.BoolectorBVNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyboolector.BoolectorNode</span></code></a></p>
<p>The class representing a Boolector bit vector node.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyboolector.BoolectorConstNode">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyboolector.</span></span><span class="sig-name descname"><span class="pre">BoolectorConstNode</span></span><a class="headerlink" href="#pyboolector.BoolectorConstNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyboolector.BoolectorBVNode" title="pyboolector.BoolectorBVNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyboolector.BoolectorBVNode</span></code></a></p>
<p>The class representing Boolector constant nodes.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.BoolectorConstNode.bits">
<span class="sig-name descname"><span class="pre">bits</span></span><a class="headerlink" href="#pyboolector.BoolectorConstNode.bits" title="Permalink to this definition">¶</a></dt>
<dd><p>The bit string of a Boolector constant node.</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="pyboolector.BoolectorException">
<em class="property"><span class="pre">exception</span> </em><span class="sig-prename descclassname"><span class="pre">pyboolector.</span></span><span class="sig-name descname"><span class="pre">BoolectorException</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.BoolectorException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3.9/library/exceptions.html#Exception" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<p>The class representing a Boolector exception.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyboolector.BoolectorExistsNode">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyboolector.</span></span><span class="sig-name descname"><span class="pre">BoolectorExistsNode</span></span><a class="headerlink" href="#pyboolector.BoolectorExistsNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyboolector.BoolectorQuantNode" title="pyboolector.BoolectorQuantNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyboolector.BoolectorQuantNode</span></code></a></p>
<p>The class representing a Boolector existentially quantified node.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyboolector.BoolectorForallNode">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyboolector.</span></span><span class="sig-name descname"><span class="pre">BoolectorForallNode</span></span><a class="headerlink" href="#pyboolector.BoolectorForallNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyboolector.BoolectorQuantNode" title="pyboolector.BoolectorQuantNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyboolector.BoolectorQuantNode</span></code></a></p>
<p>The class representing a Boolector universally quantified node.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyboolector.BoolectorFunNode">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyboolector.</span></span><span class="sig-name descname"><span class="pre">BoolectorFunNode</span></span><a class="headerlink" href="#pyboolector.BoolectorFunNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyboolector.BoolectorNode" title="pyboolector.BoolectorNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyboolector.BoolectorNode</span></code></a></p>
<p>The class representing a Boolector function node.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.BoolectorFunNode.arity">
<span class="sig-name descname"><span class="pre">arity</span></span><a class="headerlink" href="#pyboolector.BoolectorFunNode.arity" title="Permalink to this definition">¶</a></dt>
<dd><p>The arity of a Boolector function node.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyboolector.BoolectorOpt">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyboolector.</span></span><span class="sig-name descname"><span class="pre">BoolectorOpt</span></span><a class="headerlink" href="#pyboolector.BoolectorOpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3.9/library/functions.html#object" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>The class representing a Boolector option.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.BoolectorOpt.desc">
<span class="sig-name descname"><span class="pre">desc</span></span><a class="headerlink" href="#pyboolector.BoolectorOpt.desc" title="Permalink to this definition">¶</a></dt>
<dd><p>The description of a Boolector option.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.BoolectorOpt.dflt">
<span class="sig-name descname"><span class="pre">dflt</span></span><a class="headerlink" href="#pyboolector.BoolectorOpt.dflt" title="Permalink to this definition">¶</a></dt>
<dd><p>The default value of a Boolector option.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.BoolectorOpt.lng">
<span class="sig-name descname"><span class="pre">lng</span></span><a class="headerlink" href="#pyboolector.BoolectorOpt.lng" title="Permalink to this definition">¶</a></dt>
<dd><p>The long name of a Boolector option.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.BoolectorOpt.max">
<span class="sig-name descname"><span class="pre">max</span></span><a class="headerlink" href="#pyboolector.BoolectorOpt.max" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum value of a Boolector option.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.BoolectorOpt.min">
<span class="sig-name descname"><span class="pre">min</span></span><a class="headerlink" href="#pyboolector.BoolectorOpt.min" title="Permalink to this definition">¶</a></dt>
<dd><p>The minimum value of a Boolector option.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.BoolectorOpt.shrt">
<span class="sig-name descname"><span class="pre">shrt</span></span><a class="headerlink" href="#pyboolector.BoolectorOpt.shrt" title="Permalink to this definition">¶</a></dt>
<dd><p>The short name of a Boolector option.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyboolector.BoolectorOpt.val">
<span class="sig-name descname"><span class="pre">val</span></span><a class="headerlink" href="#pyboolector.BoolectorOpt.val" title="Permalink to this definition">¶</a></dt>
<dd><p>The current value of a Boolector option.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyboolector.BoolectorOptions">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyboolector.</span></span><span class="sig-name descname"><span class="pre">BoolectorOptions</span></span><a class="headerlink" href="#pyboolector.BoolectorOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3.9/library/functions.html#object" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>The class representing a Boolector option iterator (see
<a class="reference internal" href="#pyboolector.Boolector.Options" title="pyboolector.Boolector.Options"><code class="xref py py-func docutils literal notranslate"><span class="pre">Options()</span></code></a>).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyboolector.BoolectorQuantNode">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyboolector.</span></span><span class="sig-name descname"><span class="pre">BoolectorQuantNode</span></span><a class="headerlink" href="#pyboolector.BoolectorQuantNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyboolector.BoolectorBVNode" title="pyboolector.BoolectorBVNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyboolector.BoolectorBVNode</span></code></a></p>
<p>The class representing a Boolector quantified node.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.BoolectorQuantNode.is_exists">
<span class="sig-name descname"><span class="pre">is_exists</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.BoolectorQuantNode.is_exists" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>True if node is an existential quantifier.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyboolector.BoolectorQuantNode.is_forall">
<span class="sig-name descname"><span class="pre">is_forall</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyboolector.BoolectorQuantNode.is_forall" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>True if node is a universal quantifier.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyboolector.BoolectorSort">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyboolector.</span></span><span class="sig-name descname"><span class="pre">BoolectorSort</span></span><a class="headerlink" href="#pyboolector.BoolectorSort" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3.9/library/functions.html#object" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>The class representing a Boolector sort.</p>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="pyboolector_options.html" class="btn btn-neutral float-right" title="Boolector Options" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="pyboolector.html" class="btn btn-neutral float-left" title="Boolector Python API documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, the authors of Boolector.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>