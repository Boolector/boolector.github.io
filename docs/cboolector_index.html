
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>C Interface &#8212; Boolector 3.1.0 documentation</title>
    <link rel="stylesheet" href="static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script type="text/javascript" src="static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Boolector Options" href="cboolector_options.html" />
    <link rel="prev" title="Boolector C API documentation" href="cboolector.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="cboolector_options.html" title="Boolector Options"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cboolector.html" title="Boolector C API documentation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Boolector 3.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="cboolector.html" accesskey="U">Boolector C API documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">C Interface</a><ul>
<li><a class="reference internal" href="#macros">Macros</a></li>
<li><a class="reference internal" href="#typedefs">Typedefs</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#deprecated">Deprecated</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="cboolector.html"
                        title="previous chapter">Boolector C API documentation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="cboolector_options.html"
                        title="next chapter">Boolector Options</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="c-interface">
<h1>C Interface<a class="headerlink" href="#c-interface" title="Permalink to this headline">¶</a></h1>
<div class="section" id="macros">
<span id="id1"></span><h2>Macros<a class="headerlink" href="#macros" title="Permalink to this headline">¶</a></h2>
<dl class="macro">
<dt id="c.BOOLECTOR_PARSE_ERROR">
<code class="sig-name descname">BOOLECTOR_PARSE_ERROR</code><a class="headerlink" href="#c.BOOLECTOR_PARSE_ERROR" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocessor constant representing status <code class="docutils literal notranslate"><span class="pre">parse</span> <span class="pre">error</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_parse" title="boolector_parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_parse()</span></code></a></p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.BOOLECTOR_PARSE_UNKNOWN">
<code class="sig-name descname">BOOLECTOR_PARSE_UNKNOWN</code><a class="headerlink" href="#c.BOOLECTOR_PARSE_UNKNOWN" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocessor constant representing status <code class="docutils literal notranslate"><span class="pre">parse</span> <span class="pre">unknown</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_parse" title="boolector_parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_parse()</span></code></a></p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.BOOLECTOR_SAT">
<code class="sig-name descname">BOOLECTOR_SAT</code><a class="headerlink" href="#c.BOOLECTOR_SAT" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocessor constant representing status <code class="docutils literal notranslate"><span class="pre">satisfiable</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_sat()</span></code></a>, <a class="reference internal" href="#c.boolector_limited_sat" title="boolector_limited_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_limited_sat()</span></code></a>, <a class="reference internal" href="#c.boolector_simplify" title="boolector_simplify"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_simplify()</span></code></a></p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.BOOLECTOR_UNKNOWN">
<code class="sig-name descname">BOOLECTOR_UNKNOWN</code><a class="headerlink" href="#c.BOOLECTOR_UNKNOWN" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocessor constant representing status <code class="docutils literal notranslate"><span class="pre">unknown</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_sat()</span></code></a>, <a class="reference internal" href="#c.boolector_limited_sat" title="boolector_limited_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_limited_sat()</span></code></a>, <a class="reference internal" href="#c.boolector_simplify" title="boolector_simplify"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_simplify()</span></code></a></p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.BOOLECTOR_UNSAT">
<code class="sig-name descname">BOOLECTOR_UNSAT</code><a class="headerlink" href="#c.BOOLECTOR_UNSAT" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocessor constant representing status <code class="docutils literal notranslate"><span class="pre">unsatisfiable</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_sat()</span></code></a>, <a class="reference internal" href="#c.boolector_limited_sat" title="boolector_limited_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_limited_sat()</span></code></a>, <a class="reference internal" href="#c.boolector_simplify" title="boolector_simplify"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_simplify()</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="typedefs">
<h2>Typedefs<a class="headerlink" href="#typedefs" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.boolector_add">
BoolectorNode *<code class="sig-name descname">boolector_add</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector addition.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector addition with the same bit width as the operands.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_and">
BoolectorNode *<code class="sig-name descname">boolector_and</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_and" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit-vector <em>and</em>.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as the operands.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_apply">
BoolectorNode *<code class="sig-name descname">boolector_apply</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> **arg_nodes</em>, uint32_t<em> argc</em>, BoolectorNode<em> *n_fun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a function application on function <code class="docutils literal notranslate"><span class="pre">n_fun</span></code> with arguments
<code class="docutils literal notranslate"><span class="pre">arg_nodes</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>arg_nodes</strong> – Arguments to be applied.</p></li>
<li><p><strong>argc</strong> – Number of arguments to be applied.</p></li>
<li><p><strong>n_fun</strong> – Function expression.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Function application on function <code class="docutils literal notranslate"><span class="pre">n_fun</span></code> with arguments
<code class="docutils literal notranslate"><span class="pre">arg_nodes</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_fun" title="boolector_fun"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_fun()</span></code></a>, <a class="reference internal" href="#c.boolector_uf" title="boolector_uf"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_uf()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_array">
BoolectorNode *<code class="sig-name descname">boolector_array</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em>, const char<em> *symbol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a one-dimensional bit-vector array with sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
<p>An array variable’s symbol is used as a simple means of identification,
either when printing a model via <a class="reference internal" href="#c.boolector_print_model" title="boolector_print_model"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_print_model()</span></code></a>, or generating file
dumps via <a class="reference internal" href="#c.boolector_dump_btor" title="boolector_dump_btor"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_dump_btor()</span></code></a> and <a class="reference internal" href="#c.boolector_dump_smt2" title="boolector_dump_smt2"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_dump_smt2()</span></code></a>.
A symbol must be unique but may be NULL in case that no symbol should be
assigned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Array sort which maps bit-vectors to bit-vectors.</p></li>
<li><p><strong>symbol</strong> – Name of array variable.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector array of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code> and with symbol <code class="docutils literal notranslate"><span class="pre">symbol</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In contrast to composite expressions, which are maintained uniquely w.r.t.
to their kind, inputs (and consequently, bit width), array variables are
not.  Hence, each call to <a class="reference internal" href="#c.boolector_array" title="boolector_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_array()</span></code></a> with the same arguments will
return a fresh array variable.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_array_assignment">
void <code class="sig-name descname">boolector_array_assignment</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n_array</em>, char<em> ***indices</em>, char<em> ***values</em>, uint32_t<em> *size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_array_assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a model for an array expression.</p>
<p>If <a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_sat()</span></code></a> has returned <a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_SAT</span></code></a> and model generation has been
enabled.  The function creates and stores the array of indices into
<code class="docutils literal notranslate"><span class="pre">indices</span></code> and the array of corresponding values into <code class="docutils literal notranslate"><span class="pre">values</span></code>. The number
size of <code class="docutils literal notranslate"><span class="pre">indices</span></code> resp. <code class="docutils literal notranslate"><span class="pre">values</span></code> is stored into <code class="docutils literal notranslate"><span class="pre">size</span></code>. The array model
simply inspects the set of reads rho, which is associated with each array
expression. See our publication <a class="reference external" href="http://fmv.jku.at/papers/PreinerNiemetzBiere-DIFTS13.pdf">Lemmas on Demand for Lambdas</a> for details. At
indices that do not occur in the model, it is assumed that the array stores a
globally unique default value, for example 0.  The bit-vector assignments to
the indices and values have to be freed by <a class="reference internal" href="#c.boolector_free_bv_assignment" title="boolector_free_bv_assignment"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_free_bv_assignment()</span></code></a>.
Furthermore, the user has to free the array of indices and the array of
values, respectively of size <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n_array</strong> – Array operand for which the array model should be built.</p></li>
<li><p><strong>indices</strong> – Pointer to array of index strings.</p></li>
<li><p><strong>values</strong> – Pointer to array of value strings.</p></li>
<li><p><strong>size</strong> – Pointer to size.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_set_opt()</span></code></a> for enabling model generation.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_array_sort">
BoolectorSort <code class="sig-name descname">boolector_array_sort</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> index</em>, BoolectorSort<em> element</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_array_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Create array sort.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>index</strong> – Index sort of array.</p></li>
<li><p><strong>element</strong> – Element sort of array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Array sort which maps sort <code class="docutils literal notranslate"><span class="pre">index</span></code> to sort <code class="docutils literal notranslate"><span class="pre">element</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_array" title="boolector_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_array()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_assert">
void <code class="sig-name descname">boolector_assert</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_assert" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a constraint.</p>
<p>Use this function to assert <code class="docutils literal notranslate"><span class="pre">node</span></code>.  Added constraints can not be deleted
anymore. After <code class="docutils literal notranslate"><span class="pre">node</span></code> has been asserted, it can be safely released by
<a class="reference internal" href="#c.boolector_release" title="boolector_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_release()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Bit-vector expression with bit width one.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_assume">
void <code class="sig-name descname">boolector_assume</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_assume" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an assumption.</p>
<p>Use this function to assume <code class="docutils literal notranslate"><span class="pre">node</span></code>. You must enable Boolector’s
incremental usage via <a class="reference internal" href="#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_set_opt()</span></code></a> before you can add assumptions.  In
contrast to assertions added via <a class="reference internal" href="#c.boolector_assert" title="boolector_assert"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assert()</span></code></a>, assumptions are discarded
after each call to <a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_sat()</span></code></a>. Assumptions and assertions are logically
combined via Boolean <code class="docutils literal notranslate"><span class="pre">and</span></code>. Assumption handling in Boolector is analogous
to assumptions in MiniSAT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Bit-vector expression with bit width one.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_bitvec_sort">
BoolectorSort <code class="sig-name descname">boolector_bitvec_sort</code><span class="sig-paren">(</span>Btor<em> *btor</em>, uint32_t<em> width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_bitvec_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector sort of bit width <code class="docutils literal notranslate"><span class="pre">width</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>width</strong> – Bit width.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector sort of bit width <code class="docutils literal notranslate"><span class="pre">width</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_var" title="boolector_var"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_var()</span></code></a>, <a class="reference internal" href="#c.boolector_param" title="boolector_param"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_param()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_bitvec_sort_get_width">
uint32_t <code class="sig-name descname">boolector_bitvec_sort_get_width</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_bitvec_sort_get_width" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bit width of a bit-vector sort.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector sort.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit width of <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_bool_sort">
BoolectorSort <code class="sig-name descname">boolector_bool_sort</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_bool_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Boolean sort.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Sort of type Boolean.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_var" title="boolector_var"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_var()</span></code></a>, <a class="reference internal" href="#c.boolector_param" title="boolector_param"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_param()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_bv_assignment">
const char *<code class="sig-name descname">boolector_bv_assignment</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_bv_assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an assignment string for bit-vector expression if
<a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_sat()</span></code></a> has returned <a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_SAT</span></code></a> and model generation has been
enabled.</p>
<p>The expression can be an arbitrary bit-vector expression which
occurs in an assertion or current assumption. The assignment string has to
be freed by <a class="reference internal" href="#c.boolector_free_bv_assignment" title="boolector_free_bv_assignment"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_free_bv_assignment()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Bit-vector expression.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>String representing a satisfying assignment to bit-vector variables
and a consistent assignment for arbitrary bit-vector expressions.
Each character of the string can be <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">x</span></code>. The
latter represents that the corresponding bit can be assigned
arbitrarily.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_set_opt()</span></code></a> for enabling model generation.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_clone">
Btor *<code class="sig-name descname">boolector_clone</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone an instance of Boolector.</p>
<p>The resulting Boolector instance is an exact copy of given Boolector instance
<code class="docutils literal notranslate"><span class="pre">btor</span></code>.  Consequently, in a clone and its parent, nodes with the same id
correspond to each other.  Use <a class="reference internal" href="#c.boolector_match_node" title="boolector_match_node"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_match_node()</span></code></a> to match corresponding
nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Original Boolector instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The exact (but disjunct) copy of the Boolector instance <code class="docutils literal notranslate"><span class="pre">btor</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If Lingeling is used as SAT solver, Boolector can be cloned at any time,
since Lingeling also supports cloning. However, if you use <a class="reference internal" href="#c.boolector_clone" title="boolector_clone"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_clone()</span></code></a>
with MiniSAT or PicoSAT (no cloning support), Boolector can only be cloned
prior to the first <a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_sat()</span></code></a> call.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_concat">
BoolectorNode *<code class="sig-name descname">boolector_concat</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the concatenation of two bit-vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the bit width <code class="docutils literal notranslate"><span class="pre">bit</span> <span class="pre">width</span> <span class="pre">of</span> <span class="pre">n0</span> <span class="pre">+</span> <span class="pre">bit</span> <span class="pre">width</span> <span class="pre">of</span> <span class="pre">n1</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_cond">
BoolectorNode *<code class="sig-name descname">boolector_cond</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n_cond</em>, BoolectorNode<em> *n_then</em>, BoolectorNode<em> *n_else</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_cond" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an if-then-else.</p>
<p>If condition <code class="docutils literal notranslate"><span class="pre">n_cond</span></code> is true, then <code class="docutils literal notranslate"><span class="pre">n_then</span></code> is returned, else <code class="docutils literal notranslate"><span class="pre">n_else</span></code>
is returned.
Nodes <code class="docutils literal notranslate"><span class="pre">n_then</span></code> and <code class="docutils literal notranslate"><span class="pre">n_else</span></code> must be either both arrays or both bit
vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n_cond</strong> – Bit-vector condition with bit width one.</p></li>
<li><p><strong>n_then</strong> – Array or bit-vector operand representing the <code class="docutils literal notranslate"><span class="pre">if</span></code> case.</p></li>
<li><p><strong>n_else</strong> – Array or bit-vector operand representing the <code class="docutils literal notranslate"><span class="pre">else</span></code> case.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Either <code class="docutils literal notranslate"><span class="pre">n_then</span></code> or <code class="docutils literal notranslate"><span class="pre">n_else</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_const">
BoolectorNode *<code class="sig-name descname">boolector_const</code><span class="sig-paren">(</span>Btor<em> *btor</em>, const char<em> *bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_const" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector constant representing the bit-vector <code class="docutils literal notranslate"><span class="pre">bits</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>bits</strong> – Non-empty and terminated string consisting of zeroes and/or ones
representing the bit-vector constant specified by <code class="docutils literal notranslate"><span class="pre">bits</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector constant with bit width <code class="docutils literal notranslate"><span class="pre">strlen</span> <span class="pre">(bits)</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_const_array">
BoolectorNode *<code class="sig-name descname">boolector_const_array</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em>, BoolectorNode<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_const_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a one-dimensional constant bit-vector array with sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>
initialized with value <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Array sort which maps bit-vectors to bit-vectors.</p></li>
<li><p><strong>value</strong> – Value to initialize array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Constant bit-vector array of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_array" title="boolector_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_array()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_constd">
BoolectorNode *<code class="sig-name descname">boolector_constd</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em>, const char<em> *str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_constd" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector constant representing the decimal number <code class="docutils literal notranslate"><span class="pre">str</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Bit-vector sort of ‘str’.</p></li>
<li><p><strong>str</strong> – Non-empty and terminated string representing a negative or
postive decimal number.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector constant with sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_consth">
BoolectorNode *<code class="sig-name descname">boolector_consth</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em>, const char<em> *str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_consth" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector constant representing the hexadecimal number <code class="docutils literal notranslate"><span class="pre">str</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Bit-vector sort of ‘str’.</p></li>
<li><p><strong>str</strong> – Non-empty and terminated string representing a hexadecimal
number.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector constant with sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_copy">
BoolectorNode *<code class="sig-name descname">boolector_copy</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy expression (increments reference counter).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node to be copied.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Node <code class="docutils literal notranslate"><span class="pre">node</span></code> with reference counter incremented.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_copy_sort">
BoolectorSort <code class="sig-name descname">boolector_copy_sort</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_copy_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy sort (increments reference counter).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Sort to be copied.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Sort <code class="docutils literal notranslate"><span class="pre">sort</span></code> with reference counter incremented.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_copyright">
const char *<code class="sig-name descname">boolector_copyright</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_copyright" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Boolector’s copyright notice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A string with Boolector’s copyright notice.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dec">
BoolectorNode *<code class="sig-name descname">boolector_dec</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dec" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector expression that decrements bit-vector <code class="docutils literal notranslate"><span class="pre">node</span></code> by one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as <code class="docutils literal notranslate"><span class="pre">node</span></code> decremented by one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_delete">
void <code class="sig-name descname">boolector_delete</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a boolector instance and free its resources.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Expressions that have not been released properly will not be
deleted from memory. Use <a class="reference internal" href="#c.boolector_get_refs" title="boolector_get_refs"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_get_refs()</span></code></a> to debug reference
counting. You can also set option <code class="docutils literal notranslate"><span class="pre">auto_cleanup</span></code> via
<a class="reference internal" href="#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_set_opt()</span></code></a> in order to do the cleanup automatically.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dump_aiger_ascii">
void <code class="sig-name descname">boolector_dump_aiger_ascii</code><span class="sig-paren">(</span>Btor<em> *btor</em>, FILE<em> *file</em>, bool<em> merge_roots</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dump_aiger_ascii" title="Permalink to this definition">¶</a></dt>
<dd><p>Dumps bit-vector formula to file in ascii AIGER format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance</p></li>
<li><p><strong>file</strong> – Output file.</p></li>
<li><p><strong>merge_roots</strong> – Merge all roots of AIG.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dump_aiger_binary">
void <code class="sig-name descname">boolector_dump_aiger_binary</code><span class="sig-paren">(</span>Btor<em> *btor</em>, FILE<em> *file</em>, bool<em> merge_roots</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dump_aiger_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Dumps bit-vector formula to file in ascii AIGER format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance</p></li>
<li><p><strong>file</strong> – Output file.</p></li>
<li><p><strong>merge_roots</strong> – Merge all roots of AIG.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dump_btor">
void <code class="sig-name descname">boolector_dump_btor</code><span class="sig-paren">(</span>Btor<em> *btor</em>, FILE<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dump_btor" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump formula to file in <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a> format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>file</strong> – File to which the formula should be dumped. The file must be
have been opened by the user before.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dump_btor2">
void <code class="sig-name descname">boolector_dump_btor2</code><span class="sig-paren">(</span>Btor *<em> btor</em>, FILE *<em> file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dump_btor2" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump formula to file in BTOR 2.0 format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>file</strong> – File to which the formula should be dumped. The file must be
have been opened by the user before.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dump_btor_node">
void <code class="sig-name descname">boolector_dump_btor_node</code><span class="sig-paren">(</span>Btor<em> *btor</em>, FILE<em> *file</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dump_btor_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively dump <code class="docutils literal notranslate"><span class="pre">node</span></code> to file in <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a> format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>file</strong> – File to which the expression should be dumped. The file must be
have been opened by the user before.</p></li>
<li><p><strong>node</strong> – The expression which should be dumped.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dump_smt2">
void <code class="sig-name descname">boolector_dump_smt2</code><span class="sig-paren">(</span>Btor<em> *btor</em>, FILE<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dump_smt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Dumps formula to file in <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance</p></li>
<li><p><strong>file</strong> – Output file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dump_smt2_node">
void <code class="sig-name descname">boolector_dump_smt2_node</code><span class="sig-paren">(</span>Btor<em> *btor</em>, FILE<em> *file</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dump_smt2_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively dump <code class="docutils literal notranslate"><span class="pre">node</span></code> to file in <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>file</strong> – File to which the expression should be dumped. The file must be
have been opened by the user before.</p></li>
<li><p><strong>node</strong> – The expression which should be dumped.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_eq">
BoolectorNode *<code class="sig-name descname">boolector_eq</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector or array equality.</p>
<p>Both operands are either bit-vectors with the same bit width or arrays
of the same type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First operand.</p></li>
<li><p><strong>n1</strong> – Second operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_exists">
BoolectorNode *<code class="sig-name descname">boolector_exists</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *param[]</em>, uint32_t<em> paramc</em>, BoolectorNode<em> *body</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an existentially quantifed term.</p>
<p>exists (params[0] … params[paramc - 1]) body</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>params</strong> – Array of quantified variables.</p></li>
<li><p><strong>paramc</strong> – length of <code class="docutils literal notranslate"><span class="pre">params</span></code> array.</p></li>
<li><p><strong>body</strong> – Term where <code class="docutils literal notranslate"><span class="pre">params</span></code> may occur.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Existentially quantified term with bit width 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_failed">
bool <code class="sig-name descname">boolector_failed</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_failed" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if assumption <code class="docutils literal notranslate"><span class="pre">node</span></code> is a failed assumption.</p>
<p>Failed assumptions are those assumptions, that force an input formula
to become unsatisfiable. Failed assumptions handling in Boolector is
analogous to failed assumptions in MiniSAT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Bit-vector expression with bit width one.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>true if assumption is failed, and false otherwise.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assume()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_false">
BoolectorNode *<code class="sig-name descname">boolector_false</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_false" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector constant zero with bit width one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector constant zero with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_first_opt">
BtorOption <code class="sig-name descname">boolector_first_opt</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_first_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the opt of the first option in Boolector’s option list.</p>
<p>Given a Boolector instance <code class="docutils literal notranslate"><span class="pre">btor</span></code>, you can use this in combination
with <a class="reference internal" href="#c.boolector_has_opt" title="boolector_has_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_has_opt()</span></code></a> and <a class="reference internal" href="#c.boolector_next_opt" title="boolector_next_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_next_opt()</span></code></a> in order to iterate over
Boolector options as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">boolector_first_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
     <span class="n">boolector_has_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
     <span class="n">s</span> <span class="o">=</span> <span class="n">boolector_next_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
  <span class="p">{...}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Btor instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>opt of the first option in Boolector’s option list.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_fixate_assumptions">
void <code class="sig-name descname">boolector_fixate_assumptions</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_fixate_assumptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Add all assumptions as assertions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assume()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_forall">
BoolectorNode *<code class="sig-name descname">boolector_forall</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *params[]</em>, uint32_t<em> paramc</em>, BoolectorNode<em> *body</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_forall" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a universally quantified term.</p>
<p>forall (params[0] … params[paramc - 1]) body</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>params</strong> – Array of quantified variables.</p></li>
<li><p><strong>paramc</strong> – length of <code class="docutils literal notranslate"><span class="pre">params</span></code> array.</p></li>
<li><p><strong>body</strong> – Term where <code class="docutils literal notranslate"><span class="pre">params</span></code> may occur.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Universally quantified term with bit width 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_free_array_assignment">
void <code class="sig-name descname">boolector_free_array_assignment</code><span class="sig-paren">(</span>Btor<em> *btor</em>, char<em> **indices</em>, char<em> **values</em>, uint32_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_free_array_assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Free an assignment string for arrays of bit-vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>indices</strong> – Array of index strings of size <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p></li>
<li><p><strong>values</strong> – Array of values strings of size <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p></li>
<li><p><strong>size</strong> – Size of arrays <code class="docutils literal notranslate"><span class="pre">indices</span></code> and <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_array_assignment" title="boolector_array_assignment"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_array_assignment()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_free_bits">
void <code class="sig-name descname">boolector_free_bits</code><span class="sig-paren">(</span>Btor<em> *btor</em>, const char<em> *bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_free_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Free a bits string for bit-vector constants.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>bits</strong> – String which has to be freed.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_get_bits" title="boolector_get_bits"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_get_bits()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_free_bv_assignment">
void <code class="sig-name descname">boolector_free_bv_assignment</code><span class="sig-paren">(</span>Btor<em> *btor</em>, const char<em> *assignment</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_free_bv_assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Free an assignment string for bit-vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>assignment</strong> – String which has to be freed.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_bv_assignment" title="boolector_bv_assignment"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_bv_assignment()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_free_uf_assignment">
void <code class="sig-name descname">boolector_free_uf_assignment</code><span class="sig-paren">(</span>Btor<em> *btor</em>, char<em> **args</em>, char<em> **values</em>, uint32_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_free_uf_assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Free assignment strings for uninterpreted functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>args</strong> – Array of argument strings of size <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p></li>
<li><p><strong>values</strong> – Array of value string of size <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p></li>
<li><p><strong>size</strong> – Size of arrays <code class="docutils literal notranslate"><span class="pre">args</span></code> and <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_uf_assignment" title="boolector_uf_assignment"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_uf_assignment()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_fun">
BoolectorNode *<code class="sig-name descname">boolector_fun</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> **param_nodes</em>, uint32_t<em> paramc</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a function with body <code class="docutils literal notranslate"><span class="pre">node</span></code> parameterized over parameters
<code class="docutils literal notranslate"><span class="pre">param_nodes</span></code>.</p>
<p>This kind of node is similar to macros in the SMT-LIB standard 2.0.
Note that as soon as a parameter is bound to a function, it can not be
reused in other functions.
Call a function via <a class="reference internal" href="#c.boolector_apply" title="boolector_apply"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_apply()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>param_nodes</strong> – Parameters of function.</p></li>
<li><p><strong>paramc</strong> – Number of parameters.</p></li>
<li><p><strong>node</strong> – Function body parameterized over <code class="docutils literal notranslate"><span class="pre">param_nodes</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Function over parameterized expression <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_apply" title="boolector_apply"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_apply()</span></code></a>, <a class="reference internal" href="#c.boolector_param" title="boolector_param"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_param()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_fun_get_codomain_sort">
BoolectorSort <code class="sig-name descname">boolector_fun_get_codomain_sort</code><span class="sig-paren">(</span>Btor<em> *btor</em>, const BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_fun_get_codomain_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the codomain sort of given function node <code class="docutils literal notranslate"><span class="pre">node</span></code>.
The result does not have to be released.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector function node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Codomain sort of function <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_fun_get_domain_sort">
BoolectorSort <code class="sig-name descname">boolector_fun_get_domain_sort</code><span class="sig-paren">(</span>Btor<em> *btor</em>, const BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_fun_get_domain_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the domain sort of given function node <code class="docutils literal notranslate"><span class="pre">node</span></code>.
The result does not have to be released.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector function node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Domain sort of function <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_fun_sort">
BoolectorSort <code class="sig-name descname">boolector_fun_sort</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> *domain</em>, uint32_t<em> arity</em>, BoolectorSort<em> codomain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_fun_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function sort.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>domain</strong> – A list of all the function arguments’ sorts.</p></li>
<li><p><strong>arity</strong> – Number of elements in domain (must be &gt; 0).</p></li>
<li><p><strong>codomain</strong> – The sort of the function’s return value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Function sort which maps given domain to given codomain.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_uf" title="boolector_uf"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_uf()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_fun_sort_check">
int32_t <code class="sig-name descname">boolector_fun_sort_check</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> **arg_nodes</em>, uint32_t<em> argc</em>, BoolectorNode<em> *n_fun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_fun_sort_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if sorts of given arguments matches the function signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>arg_nodes</strong> – Arguments to be checked.</p></li>
<li><p><strong>argc</strong> – Number of arguments to be checked.</p></li>
<li><p><strong>n_fun</strong> – Function expression.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>-1 if all sorts are correct, otherwise it returns the position of
the incorrect argument.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_bits">
const char *<code class="sig-name descname">boolector_get_bits</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bit-vector of a constant node as a bit string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Constant node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>String representing the bits of <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_btor">
Btor *<code class="sig-name descname">boolector_get_btor</code><span class="sig-paren">(</span>BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_btor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Boolector instance to which <code class="docutils literal notranslate"><span class="pre">node</span></code> belongs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Boolector instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_failed_assumptions">
BoolectorNode **<code class="sig-name descname">boolector_get_failed_assumptions</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_failed_assumptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all failed assumptions (see <a class="reference internal" href="#c.boolector_failed" title="boolector_failed"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_failed()</span></code></a>).</p>
<p>Returns the list of failed assumptions in a zero-terminated array of
pointers to BoolectorNodes. The nodes in this array do not have to be
released. The memory allocated for this array is maintained by Boolector,
it does not have to be freed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pointer to an array of pointers to BoolectorNodes.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assume()</span></code></a>
<a class="reference internal" href="#c.boolector_failed" title="boolector_failed"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_failed()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_fun_arity">
uint32_t <code class="sig-name descname">boolector_get_fun_arity</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_fun_arity" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the arity of function <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Function node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Arity of <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_index_width">
uint32_t <code class="sig-name descname">boolector_get_index_width</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n_array</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_index_width" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bit width of indices of <code class="docutils literal notranslate"><span class="pre">n_array</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n_array</strong> – Array operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit width of indices of <code class="docutils literal notranslate"><span class="pre">n_array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_node_id">
int32_t <code class="sig-name descname">boolector_get_node_id</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the id of a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Id of <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_opt">
uint32_t <code class="sig-name descname">boolector_get_opt</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BtorOption<em> opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current value of an option.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Btor instance.</p></li>
<li><p><strong>opt</strong> – Option opt.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Current value of <code class="docutils literal notranslate"><span class="pre">opt</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_opt_desc">
const char *<code class="sig-name descname">boolector_get_opt_desc</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BtorOption<em> opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_opt_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the description of an option.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Btor instance.</p></li>
<li><p><strong>opt</strong> – Option opt.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Description of <code class="docutils literal notranslate"><span class="pre">opt</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_opt_dflt">
uint32_t <code class="sig-name descname">boolector_get_opt_dflt</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BtorOption<em> opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_opt_dflt" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the default value of an option.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Btor instance.</p></li>
<li><p><strong>opt</strong> – Option opt.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Default value of <code class="docutils literal notranslate"><span class="pre">opt</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_opt_lng">
const char *<code class="sig-name descname">boolector_get_opt_lng</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BtorOption<em> opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_opt_lng" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the long name of an option.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Btor instance.</p></li>
<li><p><strong>opt</strong> – Option opt.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Short opt of <code class="docutils literal notranslate"><span class="pre">opt</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_opt_max">
uint32_t <code class="sig-name descname">boolector_get_opt_max</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BtorOption<em> opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_opt_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the max value of an option.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Btor instance.</p></li>
<li><p><strong>opt</strong> – Option opt.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Max value of <code class="docutils literal notranslate"><span class="pre">opt</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_opt_min">
uint32_t <code class="sig-name descname">boolector_get_opt_min</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BtorOption<em> opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_opt_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the min value of an option.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Btor instance.</p></li>
<li><p><strong>opt</strong> – Option opt.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Min value of <code class="docutils literal notranslate"><span class="pre">opt</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_opt_shrt">
const char *<code class="sig-name descname">boolector_get_opt_shrt</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BtorOption<em> opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_opt_shrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the short name of an option.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Btor instance.</p></li>
<li><p><strong>opt</strong> – Option opt.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Short opt of <code class="docutils literal notranslate"><span class="pre">opt</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_refs">
uint32_t <code class="sig-name descname">boolector_get_refs</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of external references to the boolector library.</p>
<p>Internally, Boolector manages an expression DAG with reference counting.
Use <a class="reference internal" href="#c.boolector_release" title="boolector_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_release()</span></code></a> to properly release an expression.  Before you
finally call <a class="reference internal" href="#c.boolector_delete" title="boolector_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_delete()</span></code></a>, <a class="reference internal" href="#c.boolector_get_refs" title="boolector_get_refs"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_get_refs()</span></code></a> should return 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Number of external references owned by the user.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_sort">
BoolectorSort <code class="sig-name descname">boolector_get_sort</code><span class="sig-paren">(</span>Btor<em> *btor</em>, const BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the sort of given <code class="docutils literal notranslate"><span class="pre">node</span></code>. The result does not have to be released.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Sort of <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_symbol">
const char *<code class="sig-name descname">boolector_get_symbol</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the symbol of an expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Symbol of expression.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_var" title="boolector_var"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_var()</span></code></a>, <a class="reference internal" href="#c.boolector_array" title="boolector_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_array()</span></code></a>, <a class="reference internal" href="#c.boolector_uf" title="boolector_uf"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_uf()</span></code></a>, <a class="reference internal" href="#c.boolector_param" title="boolector_param"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_param()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_trapi">
FILE *<code class="sig-name descname">boolector_get_trapi</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_trapi" title="Permalink to this definition">¶</a></dt>
<dd><p>Return API trace file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>API trace output file.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_width">
uint32_t <code class="sig-name descname">boolector_get_width</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_width" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bit width of an expression.</p>
<p>If the expression is an array, it returns the bit width of the array
elements.
If the expression is a function, it returns the bit width of the function’s
return value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit width of <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_git_id">
const char *<code class="sig-name descname">boolector_git_id</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_git_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Boolector’s git id string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A string with Boolector’s git id.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_has_opt">
bool <code class="sig-name descname">boolector_has_opt</code><span class="sig-paren">(</span>Btor<em> *Btor</em>, BtorOption<em> opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_has_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if Boolector has a given option.</p>
<p>Given a Boolector instance <code class="docutils literal notranslate"><span class="pre">btor</span></code>, you can use this in combination
with <a class="reference internal" href="#c.boolector_has_opt" title="boolector_has_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_has_opt()</span></code></a> and <a class="reference internal" href="#c.boolector_next_opt" title="boolector_next_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_next_opt()</span></code></a> in order to iterate over
Boolector options as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">boolector_first_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
     <span class="n">boolector_has_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
     <span class="n">s</span> <span class="o">=</span> <span class="n">boolector_next_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
  <span class="p">{...}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Btor instance.</p></li>
<li><p><strong>opt</strong> – Option opt.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if Boolector has the given option, and false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_iff">
BoolectorNode *<code class="sig-name descname">boolector_iff</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_iff" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Boolean equivalence.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have bit width one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Equivalence n0 &lt;=&gt; n1 with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_implies">
BoolectorNode *<code class="sig-name descname">boolector_implies</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_implies" title="Permalink to this definition">¶</a></dt>
<dd><p>Create boolean implication.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have bit width one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – Bit-vector node representing the premise.</p></li>
<li><p><strong>n1</strong> – Bit-vector node representing the conclusion.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Implication n0 =&gt; n1 with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_inc">
BoolectorNode *<code class="sig-name descname">boolector_inc</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_inc" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector expression that increments bit-vector <code class="docutils literal notranslate"><span class="pre">node</span></code> by one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as <code class="docutils literal notranslate"><span class="pre">node</span></code> incremented by one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_int">
BoolectorNode *<code class="sig-name descname">boolector_int</code><span class="sig-paren">(</span>Btor<em> *btor</em>, int32_t<em> i</em>, BoolectorSort<em> sort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector constant representing the signed integer <code class="docutils literal notranslate"><span class="pre">i</span></code> of sort
<code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
<p>The constant is obtained by either truncating bits or by
signed extension (padding with ones).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>i</strong> – Signed integer value.</p></li>
<li><p><strong>sort</strong> – Sort of constant.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector constant of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_array">
bool <code class="sig-name descname">boolector_is_array</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is an array node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">node</span></code> is an array, and false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_array_sort">
bool <code class="sig-name descname">boolector_is_array_sort</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_array_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if <code class="docutils literal notranslate"><span class="pre">sort</span></code> is an array sort.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Sort.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">sort</span></code> is an array sort, and false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_array_var">
bool <code class="sig-name descname">boolector_is_array_var</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_array_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if expression is an array variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">node</span></code> is an array variable, and false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_bitvec_sort">
bool <code class="sig-name descname">boolector_is_bitvec_sort</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_bitvec_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if <code class="docutils literal notranslate"><span class="pre">sort</span></code> is a bit-vector sort.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Sort.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">sort</span></code> is a bit-vector sort, and false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_bound_param">
bool <code class="sig-name descname">boolector_is_bound_param</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_bound_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given parameter node is bound by a function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Parameter node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">node</span></code> is bound, and false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_bv_const_max_signed">
bool <code class="sig-name descname">boolector_is_bv_const_max_signed</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_bv_const_max_signed" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is a bit-vector constant representing the maximum
signed value (01…1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">node</span></code> is a bit-vector constant representing the maximum
signed value, and false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_bv_const_min_signed">
bool <code class="sig-name descname">boolector_is_bv_const_min_signed</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_bv_const_min_signed" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is a bit-vector constant representing the minimum
signed value (10…0).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">node</span></code> is a bit-vector constant representing the minimum
signed value, and false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_bv_const_one">
bool <code class="sig-name descname">boolector_is_bv_const_one</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_bv_const_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is a bit-vector constant representing one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">node</span></code> is a bit-vector constant representing one, and
false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_bv_const_ones">
bool <code class="sig-name descname">boolector_is_bv_const_ones</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_bv_const_ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is a bit-vector constant representing the maximum
unsigned value (all ones)..</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">node</span></code> is a bit-vector constant with all ones, and false
otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_bv_const_zero">
bool <code class="sig-name descname">boolector_is_bv_const_zero</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_bv_const_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is a bit-vector constant representing zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">node</span></code> is a bit-vector constant representing zero, and
false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_const">
bool <code class="sig-name descname">boolector_is_const</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_const" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is a constant node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">node</span></code> is a constant, and false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_equal_sort">
bool <code class="sig-name descname">boolector_is_equal_sort</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_equal_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> have the same sort or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First operand.</p></li>
<li><p><strong>n1</strong> – Second operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> have the same sort, and false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_fun">
bool <code class="sig-name descname">boolector_is_fun</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is a function node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">node</span></code> is a function, and false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_fun_sort">
bool <code class="sig-name descname">boolector_is_fun_sort</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_fun_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if <code class="docutils literal notranslate"><span class="pre">sort</span></code> is a function sort.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Sort.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">sort</span></code> is a function sort, and false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_param">
bool <code class="sig-name descname">boolector_is_param</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is a parameter node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">node</span></code> is a parameter, and false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_uf">
bool <code class="sig-name descname">boolector_is_uf</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_uf" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is an uninterpreted function node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">node</span></code> is an uninterpreted function, and false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_var">
bool <code class="sig-name descname">boolector_is_var</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is a bit-vector variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <code class="docutils literal notranslate"><span class="pre">node</span></code> is a bit-vector variable, and false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_limited_sat">
int32_t <code class="sig-name descname">boolector_limited_sat</code><span class="sig-paren">(</span>Btor<em> *btor</em>, int32_t<em> lod_limit</em>, int32_t<em> sat_limit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_limited_sat" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve an input formula and limit the search by the number of lemmas
generated and the number of conflicts encountered by the underlying
SAT solver.</p>
<p>An input formula is defined by constraints added via <a class="reference internal" href="#c.boolector_assert" title="boolector_assert"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assert()</span></code></a>.
You can guide the search for a solution to an input formula by making
assumptions via <a class="reference internal" href="#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assume()</span></code></a>.</p>
<p>If you want to call this function multiple times then you must enable
Boolector’s incremental usage mode via <a class="reference internal" href="#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_set_opt()</span></code></a> before.
Otherwise, this function can only be called once.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>lod_limit</strong> – Limit for lemmas on demand (-1 unlimited).</p></li>
<li><p><strong>sat_limit</strong> – Conflict limit for SAT solver (-1 unlimited).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_SAT</span></code></a> if the input formula is satisfiable (under possibly
given assumptions), <a class="reference internal" href="#c.BOOLECTOR_UNSAT" title="BOOLECTOR_UNSAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_UNSAT</span></code></a> if the instance is
unsatisfiable, and <a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a> if the instance could not be
solved within given limits.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_bv_assignment" title="boolector_bv_assignment"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_bv_assignment()</span></code></a>, <a class="reference internal" href="#c.boolector_array_assignment" title="boolector_array_assignment"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_array_assignment()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_match_node">
BoolectorNode *<code class="sig-name descname">boolector_match_node</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_match_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the node belonging to Boolector instance <code class="docutils literal notranslate"><span class="pre">btor</span></code> that matches
given BoolectorNode <code class="docutils literal notranslate"><span class="pre">node</span></code> by id. This is intended to be used for handling
expressions of a cloned instance (<a class="reference internal" href="#c.boolector_clone" title="boolector_clone"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_clone()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Boolector node that matches given <code class="docutils literal notranslate"><span class="pre">node</span></code> in Boolector instance
<code class="docutils literal notranslate"><span class="pre">btor</span></code> by id.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Matching a node against another increases the reference
count of the returned match, which must therefore be released appropriately
(<a class="reference internal" href="#c.boolector_release" title="boolector_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_release()</span></code></a>).
Only nodes created before the <a class="reference internal" href="#c.boolector_clone" title="boolector_clone"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_clone()</span></code></a> call can be matched.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_match_node_by_id">
BoolectorNode *<code class="sig-name descname">boolector_match_node_by_id</code><span class="sig-paren">(</span>Btor<em> *btor</em>, int32_t<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_match_node_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the node belonging to Boolector instance <code class="docutils literal notranslate"><span class="pre">btor</span></code> that matches
given <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>id</strong> – Boolector node id.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Boolector node that matches given <code class="docutils literal notranslate"><span class="pre">node</span></code> in Boolector instance
<code class="docutils literal notranslate"><span class="pre">btor</span></code> by id.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Matching a node against another increases the reference
count of the returned match, which must therefore be released appropriately
(<a class="reference internal" href="#c.boolector_release" title="boolector_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_release()</span></code></a>).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_match_node_by_symbol">
BoolectorNode *<code class="sig-name descname">boolector_match_node_by_symbol</code><span class="sig-paren">(</span>Btor<em> *btor</em>, const char<em> *symbol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_match_node_by_symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the node belonging to Boolector instance <code class="docutils literal notranslate"><span class="pre">btor</span></code> that matches
given <code class="docutils literal notranslate"><span class="pre">symbol</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>symbol</strong> – The symbol of an expression.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Boolector node that matches given <code class="docutils literal notranslate"><span class="pre">node</span></code> in Boolector instance
<code class="docutils literal notranslate"><span class="pre">btor</span></code> by symbol.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Matching a node against another increases the reference
count of the returned match, which must therefore be released appropriately
(<a class="reference internal" href="#c.boolector_release" title="boolector_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_release()</span></code></a>).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_max_signed">
BoolectorNode *<code class="sig-name descname">boolector_max_signed</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_max_signed" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector maximum signed value constant of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Sort of constant.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector constant representing the minimum signed value
of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_min_signed">
BoolectorNode *<code class="sig-name descname">boolector_min_signed</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_min_signed" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector minimum signed value constant of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Sort of constant.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector constant representing the minimum signed value
of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_mul">
BoolectorNode *<code class="sig-name descname">boolector_mul</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bitvector multiplication.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector multiplication with the same bit width as the operands.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_nand">
BoolectorNode *<code class="sig-name descname">boolector_nand</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_nand" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit-vector <em>nand</em>.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as the operands.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ne">
BoolectorNode *<code class="sig-name descname">boolector_ne</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ne" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector or array inequality.</p>
<p>Both operands are either bit-vectors with the same bit width or arrays
of the same type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First operand.</p></li>
<li><p><strong>n1</strong> – Second operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_neg">
BoolectorNode *<code class="sig-name descname">boolector_neg</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_neg" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the two’s complement of bit-vector <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Bit-vector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector representing the two’s complement of <code class="docutils literal notranslate"><span class="pre">node</span></code> with the
same bit width as <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_new">
Btor *<code class="sig-name descname">boolector_new</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new instance of Boolector.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>New Boolector instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_next_opt">
BtorOption <code class="sig-name descname">boolector_next_opt</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BtorOption<em> opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_next_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>Given current option <code class="docutils literal notranslate"><span class="pre">opt</span></code>, get the opt of the next option in Boolector’s
option list.</p>
<p>Given a Boolector instance <code class="docutils literal notranslate"><span class="pre">btor</span></code>, you can use this in combination
with <a class="reference internal" href="#c.boolector_has_opt" title="boolector_has_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_has_opt()</span></code></a> and <a class="reference internal" href="#c.boolector_next_opt" title="boolector_next_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_next_opt()</span></code></a> in order to iterate over
Boolector options as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">boolector_first_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
     <span class="n">boolector_has_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
     <span class="n">s</span> <span class="o">=</span> <span class="n">boolector_next_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
  <span class="p">{...}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Btor instance.</p></li>
<li><p><strong>opt</strong> – Option opt.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>opt of the next option in Boolector’s option list, or 0 if no such
next option does exist.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_nor">
BoolectorNode *<code class="sig-name descname">boolector_nor</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_nor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit-vector <em>nor</em>.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as the operands.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_not">
BoolectorNode *<code class="sig-name descname">boolector_not</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_not" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the one’s complement of bit-vector <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – bit-vector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector representing the one’s complement of <code class="docutils literal notranslate"><span class="pre">node</span></code> with the
same bit width as <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_one">
BoolectorNode *<code class="sig-name descname">boolector_one</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector constant one of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Sort of constant.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector constant one of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ones">
BoolectorNode *<code class="sig-name descname">boolector_ones</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector constant of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>, where each bit is set to one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Sort of constant.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector constant -1 of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_or">
BoolectorNode *<code class="sig-name descname">boolector_or</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_or" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit-vector <em>or</em>.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as the operands.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_param">
BoolectorNode *<code class="sig-name descname">boolector_param</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em>, const char<em> *symbol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function parameter of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
<p>This kind of node is used to create parameterized expressions, which are
used to create functions. Once a parameter is bound to a function, it
cannot be re-used in other functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Parameter sort.</p></li>
<li><p><strong>symbol</strong> – Name of parameter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Parameter expression of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code> and with symbol <code class="docutils literal notranslate"><span class="pre">symbol</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_fun" title="boolector_fun"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_fun()</span></code></a>, <a class="reference internal" href="#c.boolector_apply" title="boolector_apply"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_apply()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_parse">
int32_t <code class="sig-name descname">boolector_parse</code><span class="sig-paren">(</span>Btor<em> *btor</em>, FILE<em> *infile</em>, const char<em> *infile_name</em>, FILE<em> *outfile</em>, char<em> **error_msg</em>, int32_t<em> *status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input file.</p>
<p>Input file format may be either <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a>, <a class="reference external" href="http://fmv.jku.at/papers/NiemetzPreinerWolfBiere-CAV18.pdf">BTOR2</a>, <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a>, or
<a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a>, the file type is detected automatically.  If the parser
encounters an error, an explanation of that error is stored in <code class="docutils literal notranslate"><span class="pre">error_msg</span></code>.
If the input file specifies a (known) status of the input formula (either sat
or unsat), that status is stored in <code class="docutils literal notranslate"><span class="pre">status</span></code>. All output (from commands
like e.g.  ‘check-sat’ in <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a>) is printed to <code class="docutils literal notranslate"><span class="pre">outfile</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>infile</strong> – Input file.</p></li>
<li><p><strong>infile_name</strong> – Input file name.</p></li>
<li><p><strong>outfile</strong> – Output file.</p></li>
<li><p><strong>error_msg</strong> – Error message.</p></li>
<li><p><strong>status</strong> – Status of the input formula.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>In the incremental case or in case of SMT-LIB v2 (which requires a
‘check-sat’ command), the function returns either <a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_SAT</span></code></a>,
<a class="reference internal" href="#c.BOOLECTOR_UNSAT" title="BOOLECTOR_UNSAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_UNSAT</span></code></a> or <a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a>. Otherwise, it always returns
<a class="reference internal" href="#c.BOOLECTOR_PARSE_UNKNOWN" title="BOOLECTOR_PARSE_UNKNOWN"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_PARSE_UNKNOWN</span></code></a>. If a parse error occurs the function
returns <a class="reference internal" href="#c.BOOLECTOR_PARSE_ERROR" title="BOOLECTOR_PARSE_ERROR"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_PARSE_ERROR</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_parse_btor">
int32_t <code class="sig-name descname">boolector_parse_btor</code><span class="sig-paren">(</span>Btor<em> *btor</em>, FILE<em> *infile</em>, const char<em> *infile_name</em>, FILE<em> *outfile</em>, char<em> **error_msg</em>, int32_t<em> *status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_parse_btor" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input file in BTOR format.</p>
<p>See <a class="reference internal" href="#c.boolector_parse" title="boolector_parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_parse()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>infile</strong> – Input file.</p></li>
<li><p><strong>infile_name</strong> – Input file name.</p></li>
<li><p><strong>outfile</strong> – Output file.</p></li>
<li><p><strong>error_msg</strong> – Error message.</p></li>
<li><p><strong>status</strong> – Status of the input formula.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a> or <a class="reference internal" href="#c.BOOLECTOR_PARSE_ERROR" title="BOOLECTOR_PARSE_ERROR"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_PARSE_ERROR</span></code></a> if a parse error
occurred.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_parse_btor2">
int32_t <code class="sig-name descname">boolector_parse_btor2</code><span class="sig-paren">(</span>Btor<em> *btor</em>, FILE<em> *infile</em>, const char<em> *infile_name</em>, FILE<em> *outfile</em>, char<em> **error_msg</em>, int32_t<em> *status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_parse_btor2" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input file in BTOR2 format.</p>
<p>See <a class="reference internal" href="#c.boolector_parse" title="boolector_parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_parse()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>infile</strong> – Input file.</p></li>
<li><p><strong>infile_name</strong> – Input file name.</p></li>
<li><p><strong>outfile</strong> – Output file.</p></li>
<li><p><strong>error_msg</strong> – Error message.</p></li>
<li><p><strong>status</strong> – Status of the input formula.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a> or <a class="reference internal" href="#c.BOOLECTOR_PARSE_ERROR" title="BOOLECTOR_PARSE_ERROR"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_PARSE_ERROR</span></code></a> if a parse error
occurred.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_parse_smt1">
int32_t <code class="sig-name descname">boolector_parse_smt1</code><span class="sig-paren">(</span>Btor<em> *btor</em>, FILE<em> *infile</em>, const char<em> *infile_name</em>, FILE<em> *outfile</em>, char<em> **error_msg</em>, int32_t<em> *status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_parse_smt1" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input file in <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a> format.</p>
<p>See <a class="reference internal" href="#c.boolector_parse" title="boolector_parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_parse()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>infile</strong> – Input file.</p></li>
<li><p><strong>infile_name</strong> – Input file name.</p></li>
<li><p><strong>outfile</strong> – Input file.</p></li>
<li><p><strong>error_msg</strong> – Error message.</p></li>
<li><p><strong>status</strong> – Status of the input formula.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>In the incremental case (right now <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a> only) the function
returns either <a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_SAT</span></code></a>, <a class="reference internal" href="#c.BOOLECTOR_UNSAT" title="BOOLECTOR_UNSAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_UNSAT</span></code></a> or <a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a>,
otherwise it always returns <a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a>. If a parse error
occurs the function returns <a class="reference internal" href="#c.BOOLECTOR_PARSE_ERROR" title="BOOLECTOR_PARSE_ERROR"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_PARSE_ERROR</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_parse_smt2">
int32_t <code class="sig-name descname">boolector_parse_smt2</code><span class="sig-paren">(</span>Btor<em> *btor</em>, FILE<em> *infile</em>, const char<em> *infile_name</em>, FILE<em> *outfile</em>, char<em> **error_msg</em>, int32_t<em> *status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_parse_smt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input file in <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> format. See <a class="reference internal" href="#c.boolector_parse" title="boolector_parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_parse()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>infile</strong> – Input file.</p></li>
<li><p><strong>infile_name</strong> – Input file name.</p></li>
<li><p><strong>outfile</strong> – Output file.</p></li>
<li><p><strong>error_msg</strong> – Error message.</p></li>
<li><p><strong>status</strong> – Status of the input formula.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a> or <a class="reference internal" href="#c.BOOLECTOR_PARSE_ERROR" title="BOOLECTOR_PARSE_ERROR"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_PARSE_ERROR</span></code></a> if a parse error
occurred.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_pop">
void <code class="sig-name descname">boolector_pop</code><span class="sig-paren">(</span>Btor<em> *btor</em>, uint32_t<em> level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Pop context levels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>level</strong> – Number of context levels to pop (must be at least 1).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Assumptions added via <a class="reference internal" href="#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assume()</span></code></a> are not affected by context level
changes and are only valid until the next <a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_sat()</span></code></a> call no matter at
what level they were assumed.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assume()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_print_model">
void <code class="sig-name descname">boolector_print_model</code><span class="sig-paren">(</span>Btor<em> *btor</em>, char<em> *format</em>, FILE<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_print_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Print model to output file. This function prints the model for all inputs
to the output file <code class="docutils literal notranslate"><span class="pre">file</span></code>. Supported output formats for the model to be
printed are:</p>
<ul>
<li><p><strong>btor</strong></p>
<p>Use boolector’s own output format for printing models.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">boolector_print_model</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="s">&quot;btor&quot;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
</pre></div>
</div>
<p>A possible model would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span> <span class="mi">00000100</span> <span class="n">x</span>
<span class="mi">3</span> <span class="mi">00010101</span> <span class="n">y</span>
<span class="mi">4</span><span class="p">[</span><span class="mi">00</span><span class="p">]</span> <span class="mi">01</span> <span class="n">A</span>
</pre></div>
</div>
<p>where the first column indicates the id of an input, the second column
its assignment, and the third column its name (or symbol), if any.
Note that in case that an input is an uninterpreted function or an
array variable,
values in square brackets indicate parameter resp. index values.</p>
</li>
<li><p><strong>smt2</strong></p>
<p>Use <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> format for printing models.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">boolector_print_model</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="s">&quot;smt2&quot;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
</pre></div>
</div>
<p>A possible model would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">model</span>
  <span class="p">(</span><span class="n">define</span><span class="o">-</span><span class="n">fun</span> <span class="n">x</span> <span class="p">()</span> <span class="p">(</span><span class="n">_</span> <span class="n">BitVec</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">#b00000100)</span>
  <span class="p">(</span><span class="n">define</span><span class="o">-</span><span class="n">fun</span> <span class="n">y</span> <span class="p">()</span> <span class="p">(</span><span class="n">_</span> <span class="n">BitVec</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">#b00010101)</span>
  <span class="p">(</span><span class="n">define</span><span class="o">-</span><span class="n">fun</span> <span class="n">y</span> <span class="p">(</span>
   <span class="p">(</span><span class="n">y_x0</span> <span class="p">(</span><span class="n">_</span> <span class="n">BitVec</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="p">(</span><span class="n">ite</span> <span class="p">(</span><span class="o">=</span> <span class="n">y_x0</span> <span class="c1">#b00) #b01</span>
      <span class="c1">#00))</span>
<span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>format</strong> – A string identifying the output format.</p></li>
<li><p><strong>file</strong> – Output file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_print_stats">
void <code class="sig-name descname">boolector_print_stats</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_print_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Print statistics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_push">
void <code class="sig-name descname">boolector_push</code><span class="sig-paren">(</span>Btor<em> *btor</em>, uint32_t<em> level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_push" title="Permalink to this definition">¶</a></dt>
<dd><p>Push new context levels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>level</strong> – Number of context levels to create (must be a least 1).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Assumptions added via <a class="reference internal" href="#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assume()</span></code></a> are not affected by context level
changes and are only valid until the next <a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_sat()</span></code></a> call no matter at
what level they were assumed.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assume()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_read">
BoolectorNode *<code class="sig-name descname">boolector_read</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n_array</em>, BoolectorNode<em> *n_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a read on array <code class="docutils literal notranslate"><span class="pre">n_array</span></code> at position <code class="docutils literal notranslate"><span class="pre">n_index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n_array</strong> – Array operand.</p></li>
<li><p><strong>n_index</strong> – Bit-vector index. The bit width of <code class="docutils literal notranslate"><span class="pre">n_index</span></code> must have the
same bit width as the indices of <code class="docutils literal notranslate"><span class="pre">n_array</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as the elements of <code class="docutils literal notranslate"><span class="pre">n_array</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_redand">
BoolectorNode *<code class="sig-name descname">boolector_redand</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_redand" title="Permalink to this definition">¶</a></dt>
<dd><p>Create <em>and</em> reduction of node <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
<p>All bits of <code class="docutils literal notranslate"><span class="pre">node</span></code> are combined by a Boolean <em>and</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Bit-vector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_redor">
BoolectorNode *<code class="sig-name descname">boolector_redor</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_redor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create <em>or</em> reduction of node <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
<p>All bits of node <code class="docutils literal notranslate"><span class="pre">node</span></code> are combined by a Boolean <em>or</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Bit-vector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_redxor">
BoolectorNode *<code class="sig-name descname">boolector_redxor</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_redxor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create <em>xor</em> reduction of node <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
<p>All bits of <code class="docutils literal notranslate"><span class="pre">node</span></code> are combined by a Boolean <em>xor</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Bit-vector node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_release">
void <code class="sig-name descname">boolector_release</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release expression (decrements reference counter).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node to be released.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_release_all">
void <code class="sig-name descname">boolector_release_all</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_release_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Release all expressions and sorts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_release" title="boolector_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_release()</span></code></a>, <a class="reference internal" href="#c.boolector_release_sort" title="boolector_release_sort"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_release_sort()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_release_sort">
void <code class="sig-name descname">boolector_release_sort</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_release_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Release sort (decrements reference counter).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Sort to be released.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_repeat">
BoolectorNode *<code class="sig-name descname">boolector_repeat</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em>, uint32_t<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create <code class="docutils literal notranslate"><span class="pre">n</span></code> concatenations of a given node <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Bit-vector operand.</p></li>
<li><p><strong>n</strong> – Number of times to repeat the given node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A node representing <code class="docutils literal notranslate"><span class="pre">n</span></code> concatenations of node <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_reset_assumptions">
void <code class="sig-name descname">boolector_reset_assumptions</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_reset_assumptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets all added assumptions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assume()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_reset_stats">
void <code class="sig-name descname">boolector_reset_stats</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_reset_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset statistics (time statistics not included).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_reset_time">
void <code class="sig-name descname">boolector_reset_time</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_reset_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset time statistics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_rol">
BoolectorNode *<code class="sig-name descname">boolector_rol</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_rol" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a rotate left.</p>
<p>The bit width of <code class="docutils literal notranslate"><span class="pre">n0</span></code> must be a power of two (greater than 1) and the
bit width of <code class="docutils literal notranslate"><span class="pre">n1</span></code> must be log2 of the bit width of <code class="docutils literal notranslate"><span class="pre">n0</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as <code class="docutils literal notranslate"><span class="pre">n0</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ror">
BoolectorNode *<code class="sig-name descname">boolector_ror</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ror" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a rotate right.</p>
<p>The bit width of <code class="docutils literal notranslate"><span class="pre">n0</span></code> must be a power of two (greater than 1) and the
bit width of <code class="docutils literal notranslate"><span class="pre">n1</span></code> must be log2 of the bit width of <code class="docutils literal notranslate"><span class="pre">n0</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as <code class="docutils literal notranslate"><span class="pre">n0</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_saddo">
BoolectorNode *<code class="sig-name descname">boolector_saddo</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_saddo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed bit-vector addition overflow detection.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one, which indicates if the addition of
<code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> overflows in case both operands are treated
signed.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sat">
int32_t <code class="sig-name descname">boolector_sat</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sat" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve an input formula.</p>
<p>An input formula is defined by constraints added via <a class="reference internal" href="#c.boolector_assert" title="boolector_assert"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assert()</span></code></a>.
You can guide the search for a solution to an input formula by making
assumptions via <a class="reference internal" href="#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assume()</span></code></a>.
Note that assertions and assumptions are combined by boolean <code class="docutils literal notranslate"><span class="pre">and</span></code>.</p>
<p>If you want to call this function multiple times, you must enable
Boolector’s incremental usage mode via <a class="reference internal" href="#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_set_opt()</span></code></a>
before. Otherwise, this function may only be called once.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_SAT</span></code></a> if the instance is satisfiable and <a class="reference internal" href="#c.BOOLECTOR_UNSAT" title="BOOLECTOR_UNSAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_UNSAT</span></code></a> if
the instance is unsatisfiable.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_bv_assignment" title="boolector_bv_assignment"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_bv_assignment()</span></code></a>, <a class="reference internal" href="#c.boolector_array_assignment" title="boolector_array_assignment"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_array_assignment()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sdiv">
BoolectorNode *<code class="sig-name descname">boolector_sdiv</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Create signed division.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as the operands.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Signed division is expressed by means of unsigned
division, where either node is normalized in case that its sign bit is 1.
If the sign bits of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> do not match, two’s complement
is performed on the result of the previous unsigned division.
Hence, the behavior in case of a division by zero depends on
<a class="reference internal" href="#c.boolector_udiv" title="boolector_udiv"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_udiv()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sdivo">
BoolectorNode *<code class="sig-name descname">boolector_sdivo</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sdivo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed bit-vector division overflow detection.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.
An overflow can happen if <code class="docutils literal notranslate"><span class="pre">n0</span></code> represents INT_MIN and <code class="docutils literal notranslate"><span class="pre">n1</span></code> represents -1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one, which indicates if the division of
<code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> overflows in case both operands are treated
signed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unsigned division cannot overflow.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_abort">
void <code class="sig-name descname">boolector_set_abort</code><span class="sig-paren">(</span>void (<em>*fun</em>)(const char* msg)<span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Set an abort callback that is called instead of exit on abort conditions.</p>
<p>It is recommended to set this function prior to creating Boolector instances.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is not thread safe (the function pointer is maintained as
a global variable). It you use threading, make sure to set the abort
function prior to creating threads.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> – The abort callback function.</p></li>
<li><p><strong>msg</strong> – The abort error message.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_msg_prefix">
void <code class="sig-name descname">boolector_set_msg_prefix</code><span class="sig-paren">(</span>Btor<em> *btor</em>, const char<em> *prefix</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_msg_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a verbosity message prefix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>prefix</strong> – Prefix string.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_opt">
void <code class="sig-name descname">boolector_set_opt</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BtorOption<em> opt</em>, uint32_t<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>Set option.</p>
<p>E.g., given a Boolector instance <code class="docutils literal notranslate"><span class="pre">btor</span></code>, model generation is enabled via</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">boolector_set_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">BTOR_OPT_MODEL_GEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>General Options:</strong></p>
<ul>
<li><p><strong>BTOR_OPT_MODEL_GEN</strong></p>
<div class="line-block">
<div class="line">Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1 or 2) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) generation of a
model for satisfiable instances.</div>
<div class="line">There are two modes for model generation:</div>
</div>
<ul class="simple">
<li><p>generate model for asserted expressions only (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1)</p></li>
<li><p>generate model for all expressions (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 2)</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_INCREMENTAL</strong></p>
<div class="line-block">
<div class="line">Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) incremental mode.</div>
<div class="line">Note that incremental usage turns off some optimization techniques.
Disabling incremental usage is currently not supported.</div>
</div>
</li>
<li><p><strong>BTOR_OPT_INCREMENTAL_SMT1</strong></p>
<div class="line-block">
<div class="line">Set incremental mode for SMT-LIB v1 input.</div>
</div>
<ul class="simple">
<li><p>BTOR_INCREMENTAL_SMT1_BASIC [default]:
stop after first satisfiable formula</p></li>
<li><p>BTOR_INCREMENTAL_SMT1_CONTINUE:
solve all formulas</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_INPUT_FORMAT</strong></p>
<div class="line-block">
<div class="line">Force input file format.</div>
<div class="line">If unspecified, Boolector automatically detects the input file format
while parsing.</div>
</div>
<ul class="simple">
<li><p>BTOR_INPUT_FORMAT_BTOR:
<a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a> format</p></li>
<li><p>BTOR_INPUT_FORMAT_BTOR2:
<a class="reference external" href="http://fmv.jku.at/papers/NiemetzPreinerWolfBiere-CAV18.pdf">BTOR2</a> format</p></li>
<li><p>BTOR_INPUT_FORMAT_SMT1:
<a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a> format</p></li>
<li><p>BTOR_INPUT_FORMAT_SMT2:
<a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> format</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_OUTPUT_NUMBER_FORMAT</strong></p>
<div class="line-block">
<div class="line">Force output number format.</div>
</div>
<ul class="simple">
<li><p>BTOR_OUTPUT_BASE_BIN [default]:
binary</p></li>
<li><p>BTOR_OUTPUT_BASE_HEX:
hexa-decimal</p></li>
<li><p>BTOR_OUTPUT_BASE_DEC:
decimal</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_OUTPUT_FORMAT</strong></p>
<div class="line-block">
<div class="line">Force output file format (<code class="docutils literal notranslate"><span class="pre">value</span></code>: <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a>: -1, <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a>: 1,
<a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a>: 2).</div>
</div>
<ul class="simple">
<li><p>BTOR_OUTPUT_FORMAT_BTOR [default]:
<a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a> format</p></li>
<li><p>BTOR_OUTPUT_FORMAT_BTOR2:
<a class="reference external" href="http://fmv.jku.at/papers/NiemetzPreinerWolfBiere-CAV18.pdf">BTOR2</a> format</p></li>
<li><p>BTOR_OUTPUT_FORMAT_SMT2:
<a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> format</p></li>
<li><p>BTOR_OUTPUT_FORMAT_AIGER_ASCII:
<a class="reference external" href="http://fmv.jku.at/papers/BiereHeljankoWieringa-FMV-TR-11-2.pdf">Aiger ascii format</a></p></li>
<li><p>BTOR_OUTPUT_FORMAT_AIGER_BINARY:
<a class="reference external" href="http://fmv.jku.at/papers/BiereHeljankoWieringa-FMV-TR-11-2.pdf">Aiger binary format</a></p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_ENGINE</strong></p>
<div class="line-block">
<div class="line">Set solver engine.</div>
</div>
<ul class="simple">
<li><p>BTOR_ENGINE_FUN [default]:
the default engine for all combinations of QF_AUFBV, uses lemmas on
demand for QF_AUFBV and eager bit-blasting for QF_BV</p></li>
<li><p>BTOR_ENGINE_SLS:
the score-based local search QF_BV engine</p></li>
<li><p>BTOR_ENGINE_PROP:
the propagation-based local search QF_BV engine</p></li>
<li><p>BTOR_ENGINE_AIGPROP:
the propagation-based local search QF_BV engine that operates on the
bit-blasted formula (the AIG layer)</p></li>
<li><p>BTOR_ENGINE_QUANT:
the quantifier engine (BV only)</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_SAT_ENGINE</strong></p>
<div class="line-block">
<div class="line">Set sat solver engine.</div>
<div class="line">Available option values and default values depend on the sat solvers
configured.</div>
</div>
<ul class="simple">
<li><p>BTOR_SAT_ENGINE_CADICAL:
<a class="reference external" href="https://fmv.jku.at/cadical">CaDiCaL</a></p></li>
<li><p>BTOR_SAT_ENGINE_CMS:
<a class="reference external" href="https://github.com/msoos/cryptominisat">CryptoMiniSat</a></p></li>
<li><p>BTOR_SAT_ENGINE_LINGELING:
<a class="reference external" href="https://fmv.jku.at/lingeling">Lingeling</a></p></li>
<li><p>BTOR_SAT_ENGINE_MINISAT:
<a class="reference external" href="https://github.com/niklasso/minisat">MiniSat</a></p></li>
<li><p>BTOR_SAT_ENGINE_PICOSAT:
<a class="reference external" href="http://fmv.jku.at/picosat/">PicoSAT</a></p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_AUTO_CLEANUP</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>:1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>:0) auto cleanup of all
references held on exit.</p>
</li>
<li><p><strong>BTOR_OPT_PRETTY_PRINT</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) pretty printing when
dumping.</p>
</li>
<li><p><strong>BTOR_OPT_EXIT_CODES</strong></p>
<div class="line-block">
<div class="line">Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>:1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>:0) the use of Boolector exit
codes (BOOLECTOR_SAT, BOOLECTOR_UNSAT, BOOLECTOR_UNKNOWN - see
<a class="reference internal" href="#macros"><span class="std std-ref">Macros</span></a>).</div>
<div class="line">If disabled, on exit Boolector returns 0 if success (sat or unsat), and
1 in any other case.</div>
</div>
</li>
<li><p><strong>BTOR_OPT_SEED</strong></p>
<div class="line-block">
<div class="line">Set seed for Boolector’s internal random number generator.</div>
<div class="line">Boolector uses 0 by default.</div>
</div>
</li>
</ul>
<p><strong>Simplifier Options:</strong></p>
<ul>
<li><p><strong>BTOR_OPT_REWRITE_LEVEL</strong></p>
<div class="line-block">
<div class="line">Set the rewrite level (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0-3) of the rewriting engine.</div>
<div class="line">Boolector uses rewrite level 3 by default, rewrite levels are
classified as follows:</div>
</div>
<ul class="simple">
<li><p>0: no rewriting</p></li>
<li><p>1: term level rewriting</p></li>
<li><p>2: more simplification techniques</p></li>
<li><p>3: full rewriting/simplification</p></li>
</ul>
<div class="line-block">
<div class="line">Do not alter the rewrite level of the rewriting engine after creating
expressions.</div>
</div>
</li>
<li><p><strong>BTOR_OPT_SKELETON_PREPROC</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) skeleton  preprocessing
during simplification.</p>
</li>
<li><p><strong>BTOR_OPT_ACKERMANN</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) the eager addition of
Ackermann constraints for function applications.</p>
</li>
<li><p><strong>BTOR_OPT_BETA_REDUCE</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) the eager elimination of
lambda expressions via beta reduction.</p>
</li>
<li><p><strong>BTOR_OPT_ELIMINATE_SLICES</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) slice elimination on bit
vector variables.</p>
</li>
<li><p><strong>BTOR_OPT_VAR_SUBST</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) variable substitution
during simplification.</p>
</li>
<li><p><strong>BTOR_OPT_UCOPT</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) unconstrained
optimization.</p>
</li>
<li><p><strong>BTOR_OPT_MERGE_LAMBDAS</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) merging of lambda
expressions.</p>
</li>
<li><p><strong>BTOR_OPT_EXTRACT_LAMBDAS</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) extraction of common
array patterns as lambda terms.</p>
</li>
<li><p><strong>BTOR_OPT_NORMALIZE</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) normalization of
addition, multiplication and bit-wise and.</p>
</li>
<li><p><strong>BTOR_OPT_NORMALIZE_ADD</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) normalization of
addition.</p>
</li>
</ul>
<p><strong>Fun Engine Options:</strong></p>
<ul>
<li><p><strong>BTOR_OPT_FUN_PREPROP</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) prop engine as
preprocessing step within sequential portfolio setting.</p>
</li>
<li><p><strong>BTOR_OPT_FUN_PRESLS</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) sls engine as
preprocessing step within sequential portfolio setting.</p>
</li>
<li><p><strong>BTOR_OPT_FUN_DUAL_PROP</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) dual propagation
optimization.</p>
</li>
<li><p><strong>BTOR_OPT_FUN_DUAL_PROP_QSORT</strong></p>
<div class="line-block">
<div class="line">Set order in which inputs are assumed in dual propagation clone.</div>
</div>
<ul class="simple">
<li><p>BTOR_DP_QSORT_JUST [default]:
order by score, highest score first</p></li>
<li><p>BTOR_DP_QSORT_ASC:
order by input id, ascending</p></li>
<li><p>BTOR_DP_QSORT_DESC:
order by input id, descending</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_FUN_JUST</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) justification
optimization.</p>
</li>
<li><p><strong>BTOR_OPT_FUN_JUST_HEURISTIC</strong></p>
<div class="line-block">
<div class="line">Set heuristic that determines path selection for justification
optimization.</div>
</div>
<ul class="simple">
<li><p>BTOR_JUST_HEUR_BRANCH_MIN_APP [default]:
choose branch with minimum number of applies</p></li>
<li><p>BTOR_JUST_HEUR_BRANCH_MIN_DEP:
choose branch with minimum depth</p></li>
<li><p>BTOR_JUST_HEUR_LEFT:
always choose left branch</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_FUN_LAZY_SYNTHESIZE</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) lazy synthesis of bit
vector expressions.</p>
</li>
<li><p><strong>BTOR_OPT_FUN_EAGER_LEMMAS</strong></p>
<div class="line-block">
<div class="line">Select mode for eager generation lemmas.</div>
</div>
<ul class="simple">
<li><p>BTOR_FUN_EAGER_LEMMAS_NONE:
do not generate lemmas eagerly (generate one single lemma per
refinement iteration)</p></li>
<li><p>BTOR_FUN_EAGER_LEMMAS_CONF:
only generate lemmas eagerly until the first conflict dependent on
another conflict is found</p></li>
<li><p>BTOR_FUN_EAGER_LEMMAS_ALL:
in each refinement iteration, generate lemmas for all conflicts</p></li>
</ul>
</li>
</ul>
<p><strong>SLS Engine Options:</strong></p>
<ul>
<li><p><strong>BTOR_OPT_SLS_NFIPS</strong>
Set the number of bit flips used as a limit for the sls engine. Disabled
if 0.</p></li>
<li><p><strong>BTOR_OPT_SLS_STRATEGY</strong></p>
<div class="line-block">
<div class="line">Select move strategy for SLS engine.</div>
</div>
<ul class="simple">
<li><p>BTOR_SLS_STRAT_BEST_MOVE:
always choose best score improving move</p></li>
<li><p>BTOR_SLS_STRAT_RAND_WALK:
always choose random walk weighted by score</p></li>
<li><p>BTOR_SLS_STRAT_FIRST_BEST_MOVE [default]:
always choose first best move (no matter if any other move is better)</p></li>
<li><p>BTOR_SLS_STRAT_BEST_SAME_MOVE:
determine move as best move even if its score is not better but the
same as the score of the previous best move</p></li>
<li><p>BTOR_SLS_STRAT_ALWAYS_PROP:
always choose propagation move (and recover with SLS move in case of
conflict)</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_SLS_JUST</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) justification based path
selection during candidate selection.</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_GW</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) group-wise moves, where
rather than changing the assignment of one single candidate variable, all
candidate variables are set at the same time (using the same strategy).</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_RANGE</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) range-wise bit-flip
moves, where the bits within all ranges from 2 to the bit width (starting
from the LSB) are flipped at once.</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_SEGMENT</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) segment-wise bit-flip
moves, where the bits within segments of multiples of 2 are flipped at
once.</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_RAND_WALK</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) random walk moves, where
one out of all possible neighbors is randomly selected (with given
probability, see BTOR_OPT_SLS_PROB_MOVE_RAND_WALK) for a randomly
selected candidate variable.</p>
</li>
<li><p><strong>BTOR_OPT_SLS_PROB_MOVE_RAND_WALK</strong></p>
<p>Set the probability with which a random walk is chosen if random walks
are enabled (see BTOR_OPT_SLS_MOVE_RAND_WALK).</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_RAND_ALL</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) the randomization of all
candidate variables (rather than a single randomly selected candidate
variable) in case no best move has been found.</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_RAND_RANGE</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) the randomization of bit
ranges (rather than all bits) of a candidate variable(s) to be randomized
in case no best move has been found.</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_PROP</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) propagation moves (chosen
with a given ratio of number of propagation moves to number of regular
SLS moves, see BTOR_OPT_SLS_MOVE_PROP_N_PROP and
BTOR_OPT_SLS_MOVE_PROP_N_SLS).</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_PROP_N_PROP</strong></p>
<p>Set the number of propagation moves to be performed when propagation
moves are enabled (propagation moves are chosen with a ratio of
propagation moves to regular SLS moves, see BTOR_OPT_SLS_MOVE_PROP and
BTOR_OPT_SLS_MOVE_PROP_N_SLS).</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_PROP_N_SLS</strong></p>
<p>Set the number of regular SLS moves to be performed when propagation
moves are enabled (propagation moves are chosen with a ratio of
propagation moves to regular SLS moves, see BTOR_OPT_SLS_MOVE_PROP and
BTOR_OPT_SLS_MOVE_PROP_N_PROP).</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_PROP_FORCE_RW</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) that random walks are
forcibly chosen as recovery moves in case of conflicts when a propagation
move is performed (rather than performing a regular SLS move).</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_INC_MOVE_TEST</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) that during best move
selection, if the current candidate variable with a previous neighbor
yields the currently best score, this neighbor assignment is used as a
base for further neighborhood exploration (rather than its current
assignment).</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_RESTARTS</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) restarts.</p>
</li>
<li><p><strong>BTOR_OPT_SLS_MOVE_RESTARTS</strong></p>
<div class="line-block">
<div class="line">Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) heuristic (bandit
scheme) for selecting root constraints.</div>
<div class="line">If disabled, candidate root constraints are selected randomly.</div>
</div>
</li>
</ul>
<p><strong>Prop Engine Options</strong>:</p>
<ul>
<li><p><strong>BTOR_OPT_PROP_NPROPS</strong></p>
<p>Set the number of propagation (steps) used as a limit for the propagation
engine. Disabled if 0.</p>
</li>
<li><p><strong>BTOR_OPT_PROP_USE_RESTARTS</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) restarts.</p>
</li>
<li><p><strong>BTOR_OPT_PROP_USE_RESTARTS</strong></p>
<div class="line-block">
<div class="line">Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) heuristic (bandit
scheme) for selecting root constraints.</div>
<div class="line">If enabled, root constraint selection via bandit scheme is based on a
scoring scheme similar to the one employed in the SLS engine.</div>
<div class="line">If disabled, candidate root constraints are selected randomly.</div>
</div>
</li>
<li><p><strong>BTOR_OPT_PROP_PATH_SEL</strong></p>
<p>Select mode for path selection.</p>
<ul class="simple">
<li><p>BTOR_PROP_PATH_SEL_CONTROLLING:
select path based on controlling inputs</p></li>
<li><p>BTOR_PROP_PATH_SEL_ESSENTIAL [default]:
select path based on essential inputs</p></li>
<li><p>BTOR_PROP_PATH_SEL_RANDOM:
select path based on random inputs</p></li>
</ul>
</li>
<li><p><strong>BTOR_OPT_PROP_PROB_USE_INV_VALUE</strong></p></li>
</ul>
<blockquote>
<div><p>Set probabiality with which to choose inverse values over consistent
values.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>BTOR_OPT_PROP_PROB_FLIP_COND</strong></p></li>
</ul>
<blockquote>
<div><p>Set probability with which to select the path to the condition (in case of
an if-then-else operation) rather than the enabled branch during down
propagation.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>BTOR_OPT_PROP_PROB_FLIP_COND_CONST</strong></p></li>
</ul>
<blockquote>
<div><p>Set probbiality with which to select the path to the condition (in case of
an if-then-else operation) rather than the enabled branch during down
propagation if either of the ‘then’ or ‘else’ branch is constant.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>BTOR_OPT_PROP_FLIP_COND_CONST_DELTA</strong></p></li>
</ul>
<blockquote>
<div><p>Set delta by which BTOR_OPT_PROP_PROB_FLIP_COND_CONST is decreased or
increased after a limit BTOR_OPT_PROP_FLIP_COND_CONST_NPATHSEL is reached.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>BTOR_OPT_PROP_FLIP_COND_CONST_NPATHSEL</strong></p></li>
</ul>
<blockquote>
<div><p>Set the limit for how often the path to the condition (in case of an
if-then-else operation) may be selected bevor
BTOR_OPT_PROP_PROB_FLIP_COND_CONST is decreased or increased by
BTOR_OPT_PROP_PROB_FLIP_COND_CONST_DELTA.</p>
</div></blockquote>
<ul>
<li><p><strong>BTOR_OPT_PROP_PROB_SLICE_KEEP_DC</strong></p>
<p>Set probability with which to keep the current value of the don’t care
bits of a slice operation (rather than fully randomizing all of them)
when selecting an inverse or consistent value.</p>
</li>
<li><p><strong>BTOR_OPT_PROP_PROB_CONC_FLIP</strong></p></li>
</ul>
<blockquote>
<div><p>Set probability with which to use the corresponing slice of current
assignment with max. one of its bits flipped (rather than using the
corresponding slice of the down propagated assignment) as result of
consistent value selection for concats.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>BTOR_OPT_PROP_PROB_SLICE_FLIP</strong></p></li>
</ul>
<blockquote>
<div><p>Set probability with which to use the current assignment of the operand of
a slice operation with one of the don’t care bits flipped (rather than
fully randomizing all of them, both for inverse and consistent value
selection) if their current assignment is not kept (see
BTOR_OPT_PROP_PROB_SLICE_KEEP_DC).</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>BTOR_OPT_PROP_PROB_EQ_FLIP</strong></p></li>
</ul>
<blockquote>
<div><p>Set probability with which the current assignment of the selected node
with one of its bits flipped (rather than a fully randomized bit-vector)
is down-propagated in case of an inequality (both for inverse and
consistent value selection).</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>BTOR_OPT_PROP_PROB_AND_FLIP</strong></p></li>
</ul>
<blockquote>
<div><p>Set probability with which the current assignment of the don’t care bits
of the selected node with max. one of its bits flipped (rather than fully
randomizing all of them) in case of an and operation (for both inverse and
consistent value selection).</p>
</div></blockquote>
<ul>
<li><p><strong>BTOR_OPT_PROP_NO_MOVE_ON_CONFLICT</strong></p>
<div class="line-block">
<div class="line">Do not perform a propagation move when running into a conflict during
inverse computation.</div>
<div class="line">(This is the default behavior for the SLS engine when propagation moves
are enabled, where a conflict triggers a recovery by means of a regular
SLS move.)</div>
</div>
</li>
</ul>
<p><strong>AIGProp Engine Options</strong>:</p>
<ul>
<li><p><strong>BTOR_OPT_AIGPROP_USE_RESTARTS</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) restarts.</p>
</li>
<li><p><strong>BTOR_OPT_AIGPROP_USE_RESTARTS</strong></p>
<div class="line-block">
<div class="line">Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) heuristic (bandit
scheme) for selecting root constraints.</div>
<div class="line">If enabled, root constraint selection via bandit scheme is based on a
scoring scheme similar to the one employed in the SLS engine.</div>
<div class="line">If disabled, candidate root constraints are selected randomly.</div>
</div>
</li>
<li><p><strong>BTOR_OPT_QUANT_SYNTH</strong></p></li>
</ul>
<blockquote>
<div><p>Select synthesis mode for Skolem functions.</p>
<ul class="simple">
<li><p>BTOR_QUANT_SYNTH_NONE:
do not synthesize skolem functions (use model values for instantiation)</p></li>
<li><p>BTOR_QUANT_SYNTH_EL:
use enumerative learning to synthesize skolem functions</p></li>
<li><p>BTOR_QUANT_SYNTH_ELMC:
use enumerative learning modulo the predicates in the cone of influence
of the existential variables to synthesize skolem functions</p></li>
<li><p>BTOR_QUANT_SYNTH_EL_ELMC:
chain BTOR_QUANT_SYNTH_EL and BTOR_QUANT_SYNTH_ELMC approaches to
synthesize skolem functions</p></li>
<li><p>BTOR_QUANT_SYNTH_ELMR:
use enumerative learning modulo the given root constraints to synthesize
skolem functions</p></li>
</ul>
</div></blockquote>
<ul>
<li><p><strong>BTOR_OPT_QUANT_DUAL_SOLVER</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) solving the dual
(negated) version of the quantified bit-vector formula.</p>
</li>
<li><p><strong>BTOR_OPT_QUANT_SYNTH_LIMIT</strong></p>
<p>Set the limit of enumerated expressions for the enumerative learning
synthesis algorithm.</p>
</li>
<li><p><strong>BTOR_OPT_SYNTH_QI</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) generalization of
quantifier instantiations via enumerative learning.</p>
</li>
<li><p><strong>BTOR_OPT_QUANT_DER</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) destructive equality
resolution simplification.</p>
</li>
<li><p><strong>BTOR_OPT_QUANT_CER</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) constructive equality
resolution simplification.</p>
</li>
<li><p><strong>BTOR_OPT_QUANT_MINISCOPE</strong></p>
<p>Enable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal notranslate"><span class="pre">value</span></code>: 0) miniscoping.</p>
</li>
</ul>
<div class="toctree-wrapper compound">
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>opt</strong> – Option opt.</p></li>
<li><p><strong>val</strong> – Option value.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_sat_solver">
void <code class="sig-name descname">boolector_set_sat_solver</code><span class="sig-paren">(</span>Btor<em> *btor</em>, const char<em> *solver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_sat_solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the SAT solver to use.</p>
<p>Currently, we support <code class="docutils literal notranslate"><span class="pre">Lingeling</span></code>, <code class="docutils literal notranslate"><span class="pre">PicoSAT</span></code>, and <code class="docutils literal notranslate"><span class="pre">MiniSAT</span></code> as string
value of <code class="docutils literal notranslate"><span class="pre">solver</span></code> (case insensitive).  This is however
only possible if the corresponding solvers were enabled at compile time.
Call this function after <a class="reference internal" href="#c.boolector_new" title="boolector_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_new()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance</p></li>
<li><p><strong>solver</strong> – Solver identifier string.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_symbol">
void <code class="sig-name descname">boolector_set_symbol</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em>, const char<em> *symbol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the symbol of an expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Boolector node.</p></li>
<li><p><strong>symbol</strong> – The symbol to be set.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_var" title="boolector_var"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_var()</span></code></a>, <a class="reference internal" href="#c.boolector_array" title="boolector_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_array()</span></code></a>, <a class="reference internal" href="#c.boolector_uf" title="boolector_uf"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_uf()</span></code></a>, <a class="reference internal" href="#c.boolector_param" title="boolector_param"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_param()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_term">
void <code class="sig-name descname">boolector_set_term</code><span class="sig-paren">(</span>Btor<em> *btor</em>, int32_t (<em>*fun</em>)(void *), void<em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_term" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Set a termination callback.</p>
<dl class="field-list simple">
<dt class="field-odd">param btor</dt>
<dd class="field-odd"><p>Boolector instance.</p>
</dd>
<dt class="field-even">param fun</dt>
<dd class="field-even"><p>The termination callback function.</p>
</dd>
<dt class="field-odd">param state</dt>
<dd class="field-odd"><p>The argument to the termination callback function.</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_terminate" title="boolector_terminate"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_terminate()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_trapi">
void <code class="sig-name descname">boolector_set_trapi</code><span class="sig-paren">(</span>Btor<em> *btor</em>, FILE<em> *apitrace</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_trapi" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the output API trace file and enable API tracing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>apitrace</strong> – Output file.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The API trace output file can also be set via the environment variable
BTORAPITRACE=&lt;filename&gt;.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sext">
BoolectorNode *<code class="sig-name descname">boolector_sext</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em>, uint32_t<em> width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sext" title="Permalink to this definition">¶</a></dt>
<dd><p>Create signed extension.</p>
<p>The bit-vector <code class="docutils literal notranslate"><span class="pre">node</span></code> is padded with <code class="docutils literal notranslate"><span class="pre">width</span></code> bits where the value
depends on the value of the most significant bit of node <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Bit-vector node.</p></li>
<li><p><strong>width</strong> – Number of bits to pad.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit-vector extended by <code class="docutils literal notranslate"><span class="pre">width</span></code> bits.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sgt">
BoolectorNode *<code class="sig-name descname">boolector_sgt</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sgt" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed greater than.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sgte">
BoolectorNode *<code class="sig-name descname">boolector_sgte</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sgte" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed greater than or equal.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_simplify">
int32_t <code class="sig-name descname">boolector_simplify</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplify current input formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_SAT</span></code></a> if the input formula was simplified to true,
<a class="reference internal" href="#c.BOOLECTOR_UNSAT" title="BOOLECTOR_UNSAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_UNSAT</span></code></a> if it was simplified to false, and <a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a>
otherwise.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Each call to <a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_sat()</span></code></a> simplifies the input formula as a preprocessing
step.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_slice">
BoolectorNode *<code class="sig-name descname">boolector_slice</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em>, uint32_t<em> upper</em>, uint32_t<em> lower</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit-vector slice of <code class="docutils literal notranslate"><span class="pre">node</span></code> from index <code class="docutils literal notranslate"><span class="pre">upper</span></code> to index
<code class="docutils literal notranslate"><span class="pre">lower</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Bit-vector node.</p></li>
<li><p><strong>upper</strong> – Upper index which must be greater than or equal to zero, and
less than the bit width of <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p></li>
<li><p><strong>lower</strong> – Lower index which must be greater than or equal to zero, and
less than or equal to <code class="docutils literal notranslate"><span class="pre">upper</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width <code class="docutils literal notranslate"><span class="pre">upper</span> <span class="pre">-</span> <span class="pre">lower</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sll">
BoolectorNode *<code class="sig-name descname">boolector_sll</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sll" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a logical shift left.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must either have the same bit width or
the bit width of <code class="docutils literal notranslate"><span class="pre">n0</span></code> must be a power of two (greater than 1) and the
bit width of <code class="docutils literal notranslate"><span class="pre">n1</span></code> must be log2 of the bit width of <code class="docutils literal notranslate"><span class="pre">n0</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as <code class="docutils literal notranslate"><span class="pre">n0</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_slt">
BoolectorNode *<code class="sig-name descname">boolector_slt</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_slt" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed less than.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_slte">
BoolectorNode *<code class="sig-name descname">boolector_slte</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_slte" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed less than or equal.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_smod">
BoolectorNode *<code class="sig-name descname">boolector_smod</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_smod" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a, signed remainder where its sign matches the sign of the divisor.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as the operands.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">n1</span></code> is zero, the behavior of this function depends on <a class="reference internal" href="#c.boolector_urem" title="boolector_urem"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_urem()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_smulo">
BoolectorNode *<code class="sig-name descname">boolector_smulo</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_smulo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create signed multiplication overflow detection.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one, which indicates if the multiplication
of <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> overflows in case both operands are treated
signed.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sra">
BoolectorNode *<code class="sig-name descname">boolector_sra</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sra" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an arithmetic shift right.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must either have the same bit width or
the bit width of <code class="docutils literal notranslate"><span class="pre">n0</span></code> must be a power of two (greater than 1) and the
bit width of <code class="docutils literal notranslate"><span class="pre">n1</span></code> must be log2 of the bit width of <code class="docutils literal notranslate"><span class="pre">n0</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as <code class="docutils literal notranslate"><span class="pre">n0</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_srem">
BoolectorNode *<code class="sig-name descname">boolector_srem</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_srem" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed remainder.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.
If <code class="docutils literal notranslate"><span class="pre">n1</span></code> is zero, then the result is <code class="docutils literal notranslate"><span class="pre">n0</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as the operands.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Analogously to <a class="reference internal" href="#c.boolector_sdiv" title="boolector_sdiv"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_sdiv()</span></code></a>, the signed remainder is expressed by means
of the unsigned remainder, where either node is normalized in case that its
sign bit is 1.  Hence, in case that <code class="docutils literal notranslate"><span class="pre">n1</span></code> is zero, the result depends on
<a class="reference internal" href="#c.boolector_urem" title="boolector_urem"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_urem()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_srl">
BoolectorNode *<code class="sig-name descname">boolector_srl</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_srl" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a logical shift right.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must either have the same bit width or
the bit width of <code class="docutils literal notranslate"><span class="pre">n0</span></code> must be a power of two (greater than 1) and the
bit width of <code class="docutils literal notranslate"><span class="pre">n1</span></code> must be log2 of the bit width of <code class="docutils literal notranslate"><span class="pre">n0</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as <code class="docutils literal notranslate"><span class="pre">n0</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ssubo">
BoolectorNode *<code class="sig-name descname">boolector_ssubo</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ssubo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed bit-vector subtraction overflow detection.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one, which indicates if the subtraction of
<code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> overflows in case both operands are treated
signed.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sub">
BoolectorNode *<code class="sig-name descname">boolector_sub</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit-vector subtraction.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as the operands.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_terminate">
int32_t <code class="sig-name descname">boolector_terminate</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_terminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a given Boolector instance has been terminated (and or
terminate Boolector) via the previously configured termination callback
function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if Boolector is terminated, and false otherwise.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_set_term" title="boolector_set_term"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_set_term()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_true">
BoolectorNode *<code class="sig-name descname">boolector_true</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_true" title="Permalink to this definition">¶</a></dt>
<dd><p>Create constant true. This is represented by the bit-vector constant one
with bit width one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector constant one with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_uaddo">
BoolectorNode *<code class="sig-name descname">boolector_uaddo</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_uaddo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned bit-vector addition overflow detection.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one, which indicates if the addition of
<code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> overflows in case both operands are treated
unsigned.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_udiv">
BoolectorNode *<code class="sig-name descname">boolector_udiv</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_udiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Create unsigned division.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.
If <code class="docutils literal notranslate"><span class="pre">n1</span></code> is zero, then the result is -1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as the operands.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The behavior that division by zero returns -1 does not exactly
comply with the SMT-LIB standard 1.2 and 2.0 where division by zero is
handled as uninterpreted function. Our semantics are motivated by
real circuits where division by zero cannot be uninterpreted and of course
returns a result.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_uext">
BoolectorNode *<code class="sig-name descname">boolector_uext</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *node</em>, uint32_t<em> width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_uext" title="Permalink to this definition">¶</a></dt>
<dd><p>Create unsigned extension.</p>
<p>The bit-vector <code class="docutils literal notranslate"><span class="pre">node</span></code> is padded with <code class="docutils literal notranslate"><span class="pre">width</span></code> * zeroes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>node</strong> – Bit-vector node.</p></li>
<li><p><strong>width</strong> – Number of zeroes to pad.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A bit-vector extended by <code class="docutils literal notranslate"><span class="pre">width</span></code> zeroes.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_uf">
BoolectorNode *<code class="sig-name descname">boolector_uf</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em>, const char<em> *symbol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_uf" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an uninterpreted function with sort <code class="docutils literal notranslate"><span class="pre">sort</span></code> and with symbol
<code class="docutils literal notranslate"><span class="pre">symbol</span></code>.
<code class="docutils literal notranslate"><span class="pre">btor</span></code> Boolector instance.</p>
<p>An uninterpreted function’s symbol is used as a simple means of
identification, either when printing a model via <a class="reference internal" href="#c.boolector_print_model" title="boolector_print_model"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_print_model()</span></code></a>, or
generating file dumps via <a class="reference internal" href="#c.boolector_dump_btor" title="boolector_dump_btor"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_dump_btor()</span></code></a> and
<a class="reference internal" href="#c.boolector_dump_smt2" title="boolector_dump_smt2"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_dump_smt2()</span></code></a>.  A symbol must be unique but may be NULL in case that no
symbol should be assigned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sort</strong> – Sort of the uninterpreted function.</p></li>
<li><p><strong>symbol</strong> – Name of the uninterpreted function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Uninterpreted function of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code> and with symbol <code class="docutils literal notranslate"><span class="pre">symbol</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In contrast to composite expressions, which are maintained
uniquely w.r.t. to their kind, inputs (and consequently, bit width),
uninterpreted functions are not.
Hence, each call to this function returns a fresh uninterpreted function.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_apply" title="boolector_apply"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_apply()</span></code></a>, <a class="reference internal" href="#c.boolector_fun_sort" title="boolector_fun_sort"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_fun_sort()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_uf_assignment">
void <code class="sig-name descname">boolector_uf_assignment</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n_uf</em>, char<em> ***args</em>, char<em> ***values</em>, uint32_t<em> *size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_uf_assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a model for an uninterpreted function.
The function creates and stores the assignments of the function’s arguments
to array <code class="docutils literal notranslate"><span class="pre">args</span></code> and the function’s return values to array <code class="docutils literal notranslate"><span class="pre">values</span></code>.
Arrays <code class="docutils literal notranslate"><span class="pre">args</span></code> and <code class="docutils literal notranslate"><span class="pre">values</span></code> represent assignment pairs of arguments and
values, i.e., instantiating a function with args[i] yields value values[i].
For functions with arity &gt; 1 args[i] contains a space separated string of
argument assignments, where the order of the assignment strings corresponds
to the order of the function’s arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n_uf</strong> – Uninterpreted function node.</p></li>
<li><p><strong>args</strong> – Pointer to array of argument assignment strings.</p></li>
<li><p><strong>values</strong> – Pointer to array of value assignment strings.</p></li>
<li><p><strong>size</strong> – Size of arrays <code class="docutils literal notranslate"><span class="pre">args</span></code> and <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function can only be called if <a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_sat()</span></code></a> returned
<a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_SAT</span></code></a> and model generation was enabled.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_set_opt()</span></code></a> for enabling model generation</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ugt">
BoolectorNode *<code class="sig-name descname">boolector_ugt</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ugt" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned greater than.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ugte">
BoolectorNode *<code class="sig-name descname">boolector_ugte</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ugte" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned greater than or equal.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ult">
BoolectorNode *<code class="sig-name descname">boolector_ult</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ult" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned less than.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ulte">
BoolectorNode *<code class="sig-name descname">boolector_ulte</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ulte" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned less than or equal.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_umulo">
BoolectorNode *<code class="sig-name descname">boolector_umulo</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_umulo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned bit-vector multiplication overflow detection.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one, which indicates if the multiplication
of <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> overflows in case both operands are treated
unsigned.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_unsigned_int">
BoolectorNode *<code class="sig-name descname">boolector_unsigned_int</code><span class="sig-paren">(</span>Btor<em> *btor</em>, uint32_t<em> u</em>, BoolectorSort<em> sort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_unsigned_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector constant representing the unsigned integer <code class="docutils literal notranslate"><span class="pre">u</span></code> of sort
<code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
<p>The constant is obtained by either truncating bits or by
unsigned extension (padding with zeroes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>u</strong> – Unsigned integer value.</p></li>
<li><p><strong>sort</strong> – Sort of constant.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector constant of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_urem">
BoolectorNode *<code class="sig-name descname">boolector_urem</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_urem" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned remainder.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.
If <code class="docutils literal notranslate"><span class="pre">n1</span></code> is zero, then the result is <code class="docutils literal notranslate"><span class="pre">n0</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as the operands.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As in <a class="reference internal" href="#c.boolector_udiv" title="boolector_udiv"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_udiv()</span></code></a> the behavior if <code class="docutils literal notranslate"><span class="pre">n1</span></code> is zero, does
not exactly comply with the SMT-LIB standard 1.2 and 2.0 where the result
is handled as uninterpreted function. Our semantics are motivated by
real circuits, where results can not be uninterpreted.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_usubo">
BoolectorNode *<code class="sig-name descname">boolector_usubo</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_usubo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned bit-vector subtraction overflow detection.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with bit width one, which indicates if the subtraction of
<code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> overflows in case both operands are treated
unsigned.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_var">
BoolectorNode *<code class="sig-name descname">boolector_var</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em>, const char<em> *symbol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit-vector variable of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code> and with symbol <code class="docutils literal notranslate"><span class="pre">symbol</span></code>.</p>
<p>A variable’s symbol is used as a simple means of identification, either when
printing a model via <a class="reference internal" href="#c.boolector_print_model" title="boolector_print_model"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_print_model()</span></code></a>, or generating file dumps via
<a class="reference internal" href="#c.boolector_dump_btor" title="boolector_dump_btor"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_dump_btor()</span></code></a> and <a class="reference internal" href="#c.boolector_dump_smt2" title="boolector_dump_smt2"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_dump_smt2()</span></code></a>.  A symbol
must be unique but may be NULL in case that no symbol should be assigned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Variable sort.</p></li>
<li><p><strong>symbol</strong> – Name of variable.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector variable of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code> and with symbol <code class="docutils literal notranslate"><span class="pre">symbol</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In contrast to composite expressions, which are maintained uniquely
w.r.t. to their kind, inputs (and consequently, bit width), variables are
not. Hence, each call to this function returns a fresh bit-vector variable.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_version">
const char *<code class="sig-name descname">boolector_version</code><span class="sig-paren">(</span>Btor<em> *btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Boolector’s version string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A string with Boolector’s version.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_write">
BoolectorNode *<code class="sig-name descname">boolector_write</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n_array</em>, BoolectorNode<em> *n_index</em>, BoolectorNode<em> *n_value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a write on array <code class="docutils literal notranslate"><span class="pre">n_array</span></code> at position <code class="docutils literal notranslate"><span class="pre">n_index</span></code> with value
<code class="docutils literal notranslate"><span class="pre">n_value</span></code>.</p>
<p>The array is updated at exactly one position, all other elements remain
unchanged. The bit width of <code class="docutils literal notranslate"><span class="pre">n_index</span></code> must be the same as the bit width of
the indices of <code class="docutils literal notranslate"><span class="pre">n_array</span></code>. The bit width of <code class="docutils literal notranslate"><span class="pre">n_value</span></code> must be the same as
the bit width of the elements of <code class="docutils literal notranslate"><span class="pre">n_array</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n_array</strong> – Array operand.</p></li>
<li><p><strong>n_index</strong> – Bit-vector index.</p></li>
<li><p><strong>n_value</strong> – Bit-vector value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array where the value at index <code class="docutils literal notranslate"><span class="pre">n_index</span></code> has been updated with
<code class="docutils literal notranslate"><span class="pre">n_value</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_xnor">
BoolectorNode *<code class="sig-name descname">boolector_xnor</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_xnor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit-vector <em>xnor</em>.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as the operands.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_xor">
BoolectorNode *<code class="sig-name descname">boolector_xor</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorNode<em> *n0</em>, BoolectorNode<em> *n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_xor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit-vector <em>xor</em>.</p>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">n0</span></code> and <code class="docutils literal notranslate"><span class="pre">n1</span></code> must have the same bit width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>n0</strong> – First bit-vector operand.</p></li>
<li><p><strong>n1</strong> – Second bit-vector operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector with the same bit width as the operands.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.boolector_zero">
BoolectorNode *<code class="sig-name descname">boolector_zero</code><span class="sig-paren">(</span>Btor<em> *btor</em>, BoolectorSort<em> sort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit-vector constant zero of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>btor</strong> – Boolector instance.</p></li>
<li><p><strong>sort</strong> – Sort of bit-vector constant.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Bit-vector constant zero of sort <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="deprecated">
<h2>Deprecated<a class="headerlink" href="#deprecated" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="cboolector_options.html" title="Boolector Options"
             >next</a> |</li>
        <li class="right" >
          <a href="cboolector.html" title="Boolector C API documentation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Boolector 3.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="cboolector.html" >Boolector C API documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2019 The authors of Boolector.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.
    </div>
  </body>
</html>