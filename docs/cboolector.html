

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Boolector C API documentation &mdash; Boolector 3.2.2 documentation</title>
  

  
  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="static/documentation_options.js"></script>
        <script src="static/jquery.js"></script>
        <script src="static/underscore.js"></script>
        <script src="static/doctools.js"></script>
    
    <script type="text/javascript" src="static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="C Interface" href="cboolector_index.html" />
    <link rel="prev" title="Welcome to Boolector’s API documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Boolector
          

          
          </a>

          
            
            
              <div class="version">
                3.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Boolector C API documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#interface">Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="cboolector_index.html">C Interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#quickstart">Quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="#options">Options</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#api-tracing">API Tracing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#internals">Internals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#operators">Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rewriting-and-preprocessing">Rewriting and Preprocessing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quickstart-example">Quickstart Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bit-vector-examples">Bit-Vector Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#array-examples">Array Examples</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pyboolector.html">Boolector Python API documentation</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Boolector</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Boolector C API documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="boolector-c-api-documentation">
<h1>Boolector C API documentation<a class="headerlink" href="#boolector-c-api-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="interface">
<h2>Interface<a class="headerlink" href="#interface" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="cboolector_index.html">C Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="cboolector_index.html#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="cboolector_index.html#typedefs">Typedefs</a></li>
<li class="toctree-l2"><a class="reference internal" href="cboolector_index.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="cboolector_index.html#deprecated">Deprecated</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="quickstart">
<h2>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>First, we create a Boolector instance:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="n">Btor</span> <span class="o">*</span><span class="n">btor</span> <span class="o">=</span> <span class="n">boolector_new</span> <span class="p">();</span>
</pre></div>
</div>
<p>We can configure this instance via <a class="reference internal" href="cboolector_index.html#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_set_opt()</span></code></a>
For example, if we want to enable model generation:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="n">boolector_set_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">BTOR_OPT_MODEL_GEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>For a detailed description of all configurable options, see
<a class="reference internal" href="cboolector_index.html#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_set_opt()</span></code></a>.</p>
<p>Next, we can create expressions and assert formulas via
<a class="reference internal" href="cboolector_index.html#c.boolector_assert" title="boolector_assert"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assert()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Boolector’s internal design is motivated by hardware design.
Hence we do not distinguish between type <em>Boolean</em> and type <em>bit vector
of length 1</em>.</p>
</div>
<p>If incremental usage is enabled, formulas can optionally be assumed via
<a class="reference internal" href="cboolector_index.html#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assume()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Assumptions are invalidated after a call to <a class="reference internal" href="cboolector_index.html#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_sat()</span></code></a>.</p>
</div>
<p>Alternatively, we can parse an input file prior to creating and asserting
expressions. For example, to parse an input file <cite>example.btor</cite>,
we can use <a class="reference internal" href="cboolector_index.html#c.boolector_parse" title="boolector_parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_parse()</span></code></a> (auto detects the input format) or
<a class="reference internal" href="cboolector_index.html#c.boolector_parse_btor" title="boolector_parse_btor"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_parse_btor()</span></code></a> (for parsing input files in <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a> format).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="n">error_msg</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
<span class="kt">FILE</span> <span class="o">*</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fopen</span> <span class="p">(</span><span class="s">&quot;example.btor&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">boolector_parse_btor</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="s">&quot;example.btor&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error_msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
</pre></div>
</div>
<p>In case the input issues a call to check sat (in case of SMT-LIB v2 or
incremental SMT-LIB v1), this function either returns
<a class="reference internal" href="cboolector_index.html#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_SAT</span></code></a>, <a class="reference internal" href="cboolector_index.html#c.BOOLECTOR_UNSAT" title="BOOLECTOR_UNSAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_UNSAT</span></code></a> or
<a class="reference internal" href="cboolector_index.html#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a>. In any other non-error case it returns
<a class="reference internal" href="cboolector_index.html#c.BOOLECTOR_PARSE_UNKNOWN" title="BOOLECTOR_PARSE_UNKNOWN"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_PARSE_UNKNOWN</span></code></a>.
For a more detailed description of the parsers return values, see
<a class="reference internal" href="cboolector_index.html#c.boolector_parse" title="boolector_parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_parse()</span></code></a>, <a class="reference internal" href="cboolector_index.html#c.boolector_parse_btor" title="boolector_parse_btor"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_parse_btor()</span></code></a>.
<a class="reference internal" href="cboolector_index.html#c.boolector_parse_btor2" title="boolector_parse_btor2"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_parse_btor2()</span></code></a>, <a class="reference internal" href="cboolector_index.html#c.boolector_parse_smt1" title="boolector_parse_smt1"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_parse_smt1()</span></code></a> and
<a class="reference internal" href="cboolector_index.html#c.boolector_parse_smt2" title="boolector_parse_smt2"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_parse_smt2()</span></code></a>.</p>
<p>If the parser encounters an error, it returns
<a class="reference internal" href="cboolector_index.html#c.BOOLECTOR_PARSE_ERROR" title="BOOLECTOR_PARSE_ERROR"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOLECTOR_PARSE_ERROR</span></code></a> and an explanation of that error is stored
in <code class="docutils literal notranslate"><span class="pre">error_msg</span></code>.
If the input file specifies a (known) status of the input formula (either
satisfiable or unsatisfiable), that status is stored in <code class="docutils literal notranslate"><span class="pre">status</span></code>.</p>
<p>As an example for generating and asserting expressions via
<a class="reference internal" href="cboolector_index.html#c.boolector_assert" title="boolector_assert"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_assert()</span></code></a>, consider the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">100</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">100</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">100</span>
</pre></div>
</div>
<p>Assume that this example is given with x and y as natural numbers.
We encode it with bit-vectors of size 8, and to preserve semantics,
we have to ensure that the multiplication does not overflow.</p>
<p>We first create a bit-vector sort of size 8.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="n">BoolectorSort</span> <span class="n">bvsort8</span> <span class="o">=</span> <span class="n">boolector_bitvec_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
</pre></div>
</div>
<p>Then, we create and assert the following expressions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">x</span>       <span class="o">=</span> <span class="n">boolector_var</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">bvsort8</span><span class="p">,</span> <span class="s">&quot;x&quot;</span><span class="p">);</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">y</span>       <span class="o">=</span> <span class="n">boolector_var</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">bvsort8</span><span class="p">,</span> <span class="s">&quot;y&quot;</span><span class="p">);</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">zero</span>    <span class="o">=</span> <span class="n">boolector_zero</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">bvsort8</span><span class="p">);</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">hundred</span> <span class="o">=</span> <span class="n">boolector_int</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">bvsort8</span><span class="p">);</span>

  <span class="c1">// 0 &lt; x</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">ult_x</span> <span class="o">=</span> <span class="n">boolector_ult</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ult_x</span><span class="p">);</span>

  <span class="c1">// x &lt;= 100</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">ulte_x</span> <span class="o">=</span> <span class="n">boolector_ulte</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">hundred</span><span class="p">);</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ulte_x</span><span class="p">);</span>

  <span class="c1">// 0 &lt; y</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">ult_y</span> <span class="o">=</span> <span class="n">boolector_ult</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ult_y</span><span class="p">);</span>

  <span class="c1">// y &lt;= 100</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">ulte_y</span> <span class="o">=</span> <span class="n">boolector_ulte</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">hundred</span><span class="p">);</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ulte_y</span><span class="p">);</span>

  <span class="c1">// x * y</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">mul</span> <span class="o">=</span> <span class="n">boolector_mul</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

  <span class="c1">// x * y &lt; 100</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">ult</span> <span class="o">=</span> <span class="n">boolector_ult</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">mul</span><span class="p">,</span> <span class="n">hundred</span><span class="p">);</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ult</span><span class="p">);</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">umulo</span>  <span class="o">=</span> <span class="n">boolector_umulo</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">numulo</span> <span class="o">=</span> <span class="n">boolector_not</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">umulo</span><span class="p">);</span>  <span class="c1">// prevent overflow</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">numulo</span><span class="p">);</span>
</pre></div>
</div>
<p>The satisfiability of the resulting formula can be determined via
<a class="reference internal" href="cboolector_index.html#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_sat()</span></code></a>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">boolector_sat</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
</pre></div>
</div>
<p>If the resulting formula is satisfiable and model generation has been enabled
via <a class="reference internal" href="cboolector_index.html#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_set_opt()</span></code></a>, we can either print the resulting model via
<a class="reference internal" href="cboolector_index.html#c.boolector_print_model" title="boolector_print_model"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_print_model()</span></code></a>,
or query assignments of bit vector and array variables or uninterpreted
functions via <a class="reference internal" href="cboolector_index.html#c.boolector_bv_assignment" title="boolector_bv_assignment"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_bv_assignment()</span></code></a>,
<a class="reference internal" href="cboolector_index.html#c.boolector_array_assignment" title="boolector_array_assignment"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_array_assignment()</span></code></a> and <a class="reference internal" href="cboolector_index.html#c.boolector_uf_assignment" title="boolector_uf_assignment"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_uf_assignment()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Querying assignments is not limited to variables. You can query
the assignment of any arbitrary expression.</p>
</div>
<p>The example above is satisfiable, and we can now either query the assignments
of variables <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> or print the resulting model via
<a class="reference internal" href="cboolector_index.html#c.boolector_print_model" title="boolector_print_model"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_print_model()</span></code></a>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">xstr</span> <span class="o">=</span> <span class="n">boolector_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>  <span class="c1">// returns &quot;00000100&quot;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ystr</span> <span class="o">=</span> <span class="n">boolector_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>  <span class="c1">// returns &quot;00010101&quot;</span>
</pre></div>
</div>
<p>Boolector supports printing models in its own format (“btor”) or in
<a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> format (“smt2”). We print the resulting model in <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a>
format:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="n">boolector_print_model</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="s">&quot;btor&quot;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
</pre></div>
</div>
<p>A possible model is shown below and gives the assignments of bit vector
variables <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.
The first column indicates the id of the input, the second column its
assignment, and the third column its name (or symbol) if any.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span> <span class="mi">00000001</span> <span class="n">x</span>
<span class="mi">3</span> <span class="mi">01011111</span> <span class="n">y</span>
</pre></div>
</div>
<p>In the case that the formula includes arrays as inputs, their values at a
certain index are indicated as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">4</span><span class="p">[</span><span class="mi">00</span><span class="p">]</span> <span class="mi">01</span> <span class="n">A</span>
</pre></div>
</div>
<p>Here, array <code class="docutils literal notranslate"><span class="pre">A</span></code> has id 4 with index and element bit width of 2, and its
value at index 0 is 1.</p>
<p>We now print the model of the example above in <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> format.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="n">boolector_print_model</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="s">&quot;smt2&quot;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
</pre></div>
</div>
<p>A possible model is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span>
  <span class="p">(</span><span class="n">define</span><span class="o">-</span><span class="n">fun</span> <span class="n">x</span> <span class="p">()</span> <span class="p">(</span><span class="n">_</span> <span class="n">BitVec</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">#b00000001)</span>
  <span class="p">(</span><span class="n">define</span><span class="o">-</span><span class="n">fun</span> <span class="n">y</span> <span class="p">()</span> <span class="p">(</span><span class="n">_</span> <span class="n">BitVec</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">#b01011111)</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Boolector internally represents arrays as uninterpreted functions and
prints array models as models for UF.</p>
</div>
<p>Finally, we have to clean up all created expressions (see
<a class="reference internal" href="#c-internals"><span class="std std-ref">Internals</span></a> and <a class="reference internal" href="cboolector_index.html#c.boolector_release" title="boolector_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_release()</span></code></a>) and delete Boolector
instance <code class="docutils literal notranslate"><span class="pre">btor</span></code> via <a class="reference internal" href="cboolector_index.html#c.boolector_delete" title="boolector_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_delete()</span></code></a>.
Queried assignment strings have to be freed via
<a class="reference internal" href="cboolector_index.html#c.boolector_free_bv_assignment" title="boolector_free_bv_assignment"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_free_bv_assignment()</span></code></a>,
<a class="reference internal" href="cboolector_index.html#c.boolector_free_array_assignment" title="boolector_free_array_assignment"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_free_array_assignment()</span></code></a> and
<a class="reference internal" href="cboolector_index.html#c.boolector_free_uf_assignment" title="boolector_free_uf_assignment"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_free_uf_assignment()</span></code></a>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Release expressions</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">zero</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">hundred</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ult_x</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ulte_x</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ult_y</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ulte_y</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">mul</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ult</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">numulo</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">umulo</span><span class="p">);</span>

  <span class="c1">// Release assigments</span>
  <span class="n">boolector_free_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">xstr</span><span class="p">);</span>
  <span class="n">boolector_free_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ystr</span><span class="p">);</span>

  <span class="c1">// Release sorts</span>
  <span class="n">boolector_release_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">bvsort8</span><span class="p">);</span>

  <span class="c1">// Delete Boolector instance</span>
  <span class="n">boolector_delete</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
</pre></div>
</div>
<p>The source code of the example above can be found at <a class="reference external" href="https://github.com/boolector/boolector/tree/master/examples/api/c/quickstart.c">examples/api/c/quickstart.c</a>.</p>
</div></blockquote>
</div>
<div class="section" id="options">
<h2>Options<a class="headerlink" href="#options" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Boolector can be configured either via <a class="reference internal" href="cboolector_index.html#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_set_opt()</span></code></a>,
or via environment variables of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BTOR</span><span class="o">&lt;</span><span class="n">capitalized</span> <span class="n">option</span> <span class="n">name</span> <span class="n">without</span> <span class="s1">&#39;_&#39;</span> <span class="ow">and</span> <span class="s1">&#39;:&#39;</span><span class="o">&gt;=&lt;</span><span class="n">value</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>E.g., given a Boolector instance <code class="docutils literal notranslate"><span class="pre">btor</span></code>, model generation is enabled either
via</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">boolector_set_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">BTOR_OPT_MODEL_GEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>or via setting the environment variable:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BTORMODELGEN</span><span class="o">=</span><span class="mi">1</span>
</pre></div>
</div>
<p>For a list and detailed descriptions of all available options,
see <a class="reference internal" href="cboolector_index.html#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_set_opt()</span></code></a>.</p>
</div></blockquote>
<div class="section" id="api-tracing">
<h3>API Tracing<a class="headerlink" href="#api-tracing" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>API tracing allows to record every call to Boolector’s public API. The
resulting trace can be replayed and the replayed sequence behaves exactly
like the original Boolector run.
This is particularly useful for debugging purposes, as it enables replaying
erroneous behaviour.
API tracing can be enabled either via <a class="reference internal" href="cboolector_index.html#c.boolector_set_trapi" title="boolector_set_trapi"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_set_trapi()</span></code></a> or by
setting the environment variable <code class="docutils literal notranslate"><span class="pre">BTORAPITRACE=&lt;filename&gt;</span></code>.</p>
<p>For example, given a Boolector instance <code class="docutils literal notranslate"><span class="pre">btor</span></code>, API tracing is enabled as
follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fopen</span> <span class="p">(</span><span class="s">&quot;error.trace&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="n">boolector_set_trapi</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BTORAPITRACE</span><span class="o">=</span><span class="s2">&quot;error.trace&quot;</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="internals">
<span id="c-internals"></span><h2>Internals<a class="headerlink" href="#internals" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Boolector internally maintains a <strong>directed acyclic graph (DAG)</strong> of
expressions. As a consequence, each expression maintains a reference
counter, which is initially set to 1.
Each time an expression is shared, i.e., for each API call that returns
an expression (a BoolectorNode), its reference counter is incremented
by 1. Not considering API calls that created expressions, this mainly
applies to <a class="reference internal" href="cboolector_index.html#c.boolector_copy" title="boolector_copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_copy()</span></code></a>, which simply increments the reference
counter of an expression, and <a class="reference internal" href="cboolector_index.html#c.boolector_match_node" title="boolector_match_node"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_match_node()</span></code></a> and
<a class="reference internal" href="cboolector_index.html#c.boolector_match_node_by_id" title="boolector_match_node_by_id"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_match_node_by_id()</span></code></a>, which retrieve nodes of a given
Boolector instance by id and a given node’s id.
Expressions are released via <a class="reference internal" href="cboolector_index.html#c.boolector_release" title="boolector_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_release()</span></code></a>, and if its
reference counter is decremented to zero, it is deleted from memory.</p>
<p>Note that by <strong>asserting</strong> an expression, it will be <strong>permanently added</strong> to
the formula. This means that Boolector internally holds its reference until
it is either eliminated via rewriting, or the Boolector instance is deleted.
Following from that, it is safe to release an expression as soon as you
asserted it, as long as you don’t need it for further querying.</p>
</div></blockquote>
<div class="section" id="operators">
<h3>Operators<a class="headerlink" href="#operators" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Boolector internally describes expressions by means of a set of base
operators.
Boolector’s API, however, provides a richer set of operators for
convenience, where non-base operators are internally rewritten to use
base operators only.
For example, two’s complement (<a class="reference internal" href="cboolector_index.html#c.boolector_neg" title="boolector_neg"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_neg()</span></code></a>) is expressed by means
of one’s complement.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This behaviour is not influenced by the configured rewrite level.</p>
</div>
</div></blockquote>
</div>
<div class="section" id="rewriting-and-preprocessing">
<h3>Rewriting and Preprocessing<a class="headerlink" href="#rewriting-and-preprocessing" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Boolector simplifies expressions and the expression DAG by means of
rewriting. It supports three so-called <strong>rewrite levels</strong>.
Increasing rewrite levels increase the extent of rewriting and preprocessing
performed.  Rewrite level of 0 is equivalent to disabling rewriting and
preprocessing at all.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rewriting expressions by means of base operators can not be disabled,
not even at rewrite level 0.</p>
</div>
<p>Boolector not only simplifies expressions during construction
of the expression DAG but also performs preprocessing on the DAG.
For each call to <a class="reference internal" href="cboolector_index.html#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_sat()</span></code></a>, various simplification techniques
and preprocessing phases are initiated.
You can force Boolector to initiate simplifying the expression
DAG via <a class="reference internal" href="cboolector_index.html#c.boolector_simplify" title="boolector_simplify"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_simplify()</span></code></a>.
The rewrite level can be configured via <a class="reference internal" href="cboolector_index.html#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal notranslate"><span class="pre">boolector_set_opt()</span></code></a>.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="quickstart-example">
<h3>Quickstart Example<a class="headerlink" href="#quickstart-example" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;boolector.h&quot;</span><span class="cp"></span>

<span class="kt">int</span>
<span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Create Boolector instance</span>
  <span class="n">Btor</span> <span class="o">*</span><span class="n">btor</span> <span class="o">=</span> <span class="n">boolector_new</span> <span class="p">();</span>
  <span class="c1">// Enable model generation</span>
  <span class="n">boolector_set_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">BTOR_OPT_MODEL_GEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="c1">// Create bit-vector sort of size 8</span>
  <span class="n">BoolectorSort</span> <span class="n">bvsort8</span> <span class="o">=</span> <span class="n">boolector_bitvec_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

  <span class="c1">// Create expressions</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">x</span>       <span class="o">=</span> <span class="n">boolector_var</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">bvsort8</span><span class="p">,</span> <span class="s">&quot;x&quot;</span><span class="p">);</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">y</span>       <span class="o">=</span> <span class="n">boolector_var</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">bvsort8</span><span class="p">,</span> <span class="s">&quot;y&quot;</span><span class="p">);</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">zero</span>    <span class="o">=</span> <span class="n">boolector_zero</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">bvsort8</span><span class="p">);</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">hundred</span> <span class="o">=</span> <span class="n">boolector_int</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">bvsort8</span><span class="p">);</span>

  <span class="c1">// 0 &lt; x</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">ult_x</span> <span class="o">=</span> <span class="n">boolector_ult</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ult_x</span><span class="p">);</span>

  <span class="c1">// x &lt;= 100</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">ulte_x</span> <span class="o">=</span> <span class="n">boolector_ulte</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">hundred</span><span class="p">);</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ulte_x</span><span class="p">);</span>

  <span class="c1">// 0 &lt; y</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">ult_y</span> <span class="o">=</span> <span class="n">boolector_ult</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ult_y</span><span class="p">);</span>

  <span class="c1">// y &lt;= 100</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">ulte_y</span> <span class="o">=</span> <span class="n">boolector_ulte</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">hundred</span><span class="p">);</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ulte_y</span><span class="p">);</span>

  <span class="c1">// x * y</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">mul</span> <span class="o">=</span> <span class="n">boolector_mul</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

  <span class="c1">// x * y &lt; 100</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">ult</span> <span class="o">=</span> <span class="n">boolector_ult</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">mul</span><span class="p">,</span> <span class="n">hundred</span><span class="p">);</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ult</span><span class="p">);</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">umulo</span>  <span class="o">=</span> <span class="n">boolector_umulo</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">numulo</span> <span class="o">=</span> <span class="n">boolector_not</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">umulo</span><span class="p">);</span>  <span class="c1">// prevent overflow</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">numulo</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">boolector_sat</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Expect: sat</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Boolector: &quot;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">BOOLECTOR_SAT</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;sat</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">BOOLECTOR_UNSAT</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;unsat</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">xstr</span> <span class="o">=</span> <span class="n">boolector_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>  <span class="c1">// returns &quot;00000100&quot;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ystr</span> <span class="o">=</span> <span class="n">boolector_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>  <span class="c1">// returns &quot;00010101&quot;</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;assignment of x: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xstr</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;assignment of y: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ystr</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Print model in BTOR format:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">boolector_print_model</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="s">&quot;btor&quot;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Print model in SMT-LIBv2 format:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">boolector_print_model</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="s">&quot;smt2&quot;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="c1">// Release expressions</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">zero</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">hundred</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ult_x</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ulte_x</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ult_y</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ulte_y</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">mul</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ult</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">numulo</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">umulo</span><span class="p">);</span>

  <span class="c1">// Release assigments</span>
  <span class="n">boolector_free_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">xstr</span><span class="p">);</span>
  <span class="n">boolector_free_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ystr</span><span class="p">);</span>

  <span class="c1">// Release sorts</span>
  <span class="n">boolector_release_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">bvsort8</span><span class="p">);</span>

  <span class="c1">// Delete Boolector instance</span>
  <span class="n">boolector_delete</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="bit-vector-examples">
<h3>Bit-Vector Examples<a class="headerlink" href="#bit-vector-examples" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;boolector.h&quot;</span><span class="cp"></span>

<span class="cp">#define BV1_EXAMPLE_NUM_BITS 8</span>

<span class="cm">/* We verify the XOR swap algorithm. The XOR bitwise operation can</span>
<span class="cm"> * be used to swap variables without using a temporary variable:</span>
<span class="cm"> * int x, y;</span>
<span class="cm"> * ...</span>
<span class="cm"> * x = x ^ y</span>
<span class="cm"> * y = x ^ y</span>
<span class="cm"> * x = x ^ y</span>
<span class="cm"> */</span>

<span class="kt">int</span>
<span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Btor</span> <span class="o">*</span><span class="n">btor</span><span class="p">;</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">,</span> <span class="o">*</span><span class="n">old_x</span><span class="p">,</span> <span class="o">*</span><span class="n">old_y</span><span class="p">,</span> <span class="o">*</span><span class="n">eq1</span><span class="p">,</span> <span class="o">*</span><span class="n">eq2</span><span class="p">,</span> <span class="o">*</span><span class="n">and</span><span class="p">,</span> <span class="o">*</span><span class="n">formula</span><span class="p">;</span>
  <span class="n">BoolectorSort</span> <span class="n">s</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

  <span class="n">btor</span> <span class="o">=</span> <span class="n">boolector_new</span> <span class="p">();</span>
  <span class="n">s</span>    <span class="o">=</span> <span class="n">boolector_bitvec_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">BV1_EXAMPLE_NUM_BITS</span><span class="p">);</span>
  <span class="n">x</span>    <span class="o">=</span> <span class="n">boolector_var</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">y</span>    <span class="o">=</span> <span class="n">boolector_var</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="cm">/* remember initial values of x and y */</span>
  <span class="n">old_x</span> <span class="o">=</span> <span class="n">boolector_copy</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">old_y</span> <span class="o">=</span> <span class="n">boolector_copy</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

  <span class="cm">/* x = x ^ y */</span>
  <span class="n">temp</span> <span class="o">=</span> <span class="n">boolector_xor</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

  <span class="cm">/* y = x ^ y */</span>
  <span class="n">temp</span> <span class="o">=</span> <span class="n">boolector_xor</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

  <span class="cm">/* x = x ^ y */</span>
  <span class="n">temp</span> <span class="o">=</span> <span class="n">boolector_xor</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

  <span class="cm">/* Now, we have to show that old_x = y and old_y = x */</span>
  <span class="n">eq1</span> <span class="o">=</span> <span class="n">boolector_eq</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">old_x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">eq2</span> <span class="o">=</span> <span class="n">boolector_eq</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">old_y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">and</span> <span class="o">=</span> <span class="n">boolector_and</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">);</span>

  <span class="cm">/* In order to prove that this is a theorem, we negate the whole</span>
<span class="cm">   * formula and show that the negation is unsatisfiable */</span>
  <span class="n">formula</span> <span class="o">=</span> <span class="n">boolector_not</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">and</span><span class="p">);</span>

  <span class="cm">/* We assert the formula and call Boolector */</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">formula</span><span class="p">);</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">boolector_sat</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Expect: unsat</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Boolector: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
          <span class="n">result</span> <span class="o">==</span> <span class="n">BOOLECTOR_SAT</span>
              <span class="o">?</span> <span class="s">&quot;sat&quot;</span>
              <span class="o">:</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">BOOLECTOR_UNSAT</span> <span class="o">?</span> <span class="s">&quot;unsat&quot;</span> <span class="o">:</span> <span class="s">&quot;unknown&quot;</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">BOOLECTOR_UNSAT</span><span class="p">)</span> <span class="n">abort</span> <span class="p">();</span>

  <span class="cm">/* cleanup */</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">old_x</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">old_y</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">eq1</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">eq2</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">and</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">formula</span><span class="p">);</span>
  <span class="n">boolector_release_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">boolector_get_refs</span> <span class="p">(</span><span class="n">btor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">boolector_delete</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;boolector.h&quot;</span><span class="cp"></span>

<span class="cp">#define BV2_EXAMPLE_NUM_BITS 8</span>

<span class="cm">/* We try to show the following theorem:</span>
<span class="cm"> * v1 &gt; 0 &amp; v2 &gt; 0  =&gt;  v1 + v2 &gt; 0</span>
<span class="cm"> *</span>
<span class="cm"> * The theorem is valid if v1 and v2 are naturals, but not if they</span>
<span class="cm"> * are two&#39;s complement bit-vectors as addition can overflow.</span>
<span class="cm"> */</span>

<span class="kt">int</span>
<span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Btor</span> <span class="o">*</span><span class="n">btor</span><span class="p">;</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">v1</span><span class="p">,</span> <span class="o">*</span><span class="n">v2</span><span class="p">,</span> <span class="o">*</span><span class="n">add</span><span class="p">,</span> <span class="o">*</span><span class="n">zero</span><span class="p">,</span> <span class="o">*</span><span class="n">vars_sgt_zero</span><span class="p">,</span> <span class="o">*</span><span class="n">impl</span><span class="p">;</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">v1_sgt_zero</span><span class="p">,</span> <span class="o">*</span><span class="n">v2_sgt_zero</span><span class="p">,</span> <span class="o">*</span><span class="n">add_sgt_zero</span><span class="p">,</span> <span class="o">*</span><span class="n">formula</span><span class="p">;</span>
  <span class="n">BoolectorSort</span> <span class="n">s</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">assignments</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

  <span class="n">btor</span> <span class="o">=</span> <span class="n">boolector_new</span> <span class="p">();</span>
  <span class="n">boolector_set_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">BTOR_OPT_MODEL_GEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="n">s</span>    <span class="o">=</span> <span class="n">boolector_bitvec_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">BV2_EXAMPLE_NUM_BITS</span><span class="p">);</span>
  <span class="n">v1</span>   <span class="o">=</span> <span class="n">boolector_var</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">v2</span>   <span class="o">=</span> <span class="n">boolector_var</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">zero</span> <span class="o">=</span> <span class="n">boolector_zero</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

  <span class="n">v1_sgt_zero</span>   <span class="o">=</span> <span class="n">boolector_sgt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">zero</span><span class="p">);</span>
  <span class="n">v2_sgt_zero</span>   <span class="o">=</span> <span class="n">boolector_sgt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">zero</span><span class="p">);</span>
  <span class="n">vars_sgt_zero</span> <span class="o">=</span> <span class="n">boolector_and</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">v1_sgt_zero</span><span class="p">,</span> <span class="n">v2_sgt_zero</span><span class="p">);</span>

  <span class="n">add</span>          <span class="o">=</span> <span class="n">boolector_add</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
  <span class="n">add_sgt_zero</span> <span class="o">=</span> <span class="n">boolector_sgt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">zero</span><span class="p">);</span>

  <span class="n">impl</span> <span class="o">=</span> <span class="n">boolector_implies</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">vars_sgt_zero</span><span class="p">,</span> <span class="n">add_sgt_zero</span><span class="p">);</span>

  <span class="cm">/* We negate the formula and try to show that the negation is unsatisfiable */</span>
  <span class="n">formula</span> <span class="o">=</span> <span class="n">boolector_not</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">impl</span><span class="p">);</span>

  <span class="cm">/* We assert the formula and call Boolector */</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">formula</span><span class="p">);</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">boolector_sat</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Expect: sat</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Boolector: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
          <span class="n">result</span> <span class="o">==</span> <span class="n">BOOLECTOR_SAT</span>
              <span class="o">?</span> <span class="s">&quot;sat&quot;</span>
              <span class="o">:</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">BOOLECTOR_UNSAT</span> <span class="o">?</span> <span class="s">&quot;unsat&quot;</span> <span class="o">:</span> <span class="s">&quot;unknown&quot;</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">BOOLECTOR_SAT</span><span class="p">)</span> <span class="n">abort</span> <span class="p">();</span>

  <span class="cm">/* The formula is not valid, we have found a counter-example.</span>
<span class="cm">   * Now, we are able to obtain assignments to arbitrary expressions */</span>
  <span class="n">i</span>                <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">boolector_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">zero</span><span class="p">);</span>
  <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">boolector_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">v1</span><span class="p">);</span>
  <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">boolector_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
  <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">boolector_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">add</span><span class="p">);</span>
  <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">boolector_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">v1_sgt_zero</span><span class="p">);</span>
  <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">boolector_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">v2_sgt_zero</span><span class="p">);</span>
  <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">boolector_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">vars_sgt_zero</span><span class="p">);</span>
  <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">boolector_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">add_sgt_zero</span><span class="p">);</span>
  <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">boolector_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">impl</span><span class="p">);</span>
  <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">boolector_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">formula</span><span class="p">);</span>

  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Assignment to 0: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Assignment to v1: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Assignment to v2: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Assignment to v1 + v2: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Assignment to v1 &gt; 0: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Assignment to v2 &gt; 0: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Assignment to v1 &gt; 0 &amp; v2 &gt; 0: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Assignment to v1 + v2 &gt; 0: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Assignment to v1 &gt; 0 &amp; v2 &gt; 0  =&gt; v1 + v2 &gt; 0: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
          <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Assignment to !(v1 &gt; 0 &amp; v2 &gt; 0  =&gt; v1 + v2 &gt; 0): %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
          <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">boolector_free_bv_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

  <span class="cm">/* cleanup */</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">zero</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">v1</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">add</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">impl</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">formula</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">v1_sgt_zero</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">v2_sgt_zero</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">vars_sgt_zero</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">add_sgt_zero</span><span class="p">);</span>
  <span class="n">boolector_release_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">boolector_get_refs</span> <span class="p">(</span><span class="n">btor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">boolector_delete</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="array-examples">
<h3>Array Examples<a class="headerlink" href="#array-examples" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;boolector.h&quot;</span><span class="cp"></span>

<span class="cp">#define ARRAY1_EXAMPLE_ELEM_BW 8</span>
<span class="cp">#define ARRAY1_EXAMPLE_INDEX_BW 3</span>
<span class="cp">#define ARRAY1_EXAMPLE_ARRAY_SIZE (1 &lt;&lt; ARRAY1_EXAMPLE_INDEX_BW)</span>

<span class="cm">/* We verify the following linear search algorithm. We iterate over an array</span>
<span class="cm"> * and compute a maximum value as the following pseudo code shows:</span>
<span class="cm"> *</span>
<span class="cm"> * unsigned int array[ARRAY_SIZE];</span>
<span class="cm"> * unsigned int max;</span>
<span class="cm"> * int i;</span>
<span class="cm"> * ...</span>
<span class="cm"> * max = array[0];</span>
<span class="cm"> * for (i = 1; i &lt; ARRAY_SIZE; i++)</span>
<span class="cm"> *   if (array[i] &gt; max)</span>
<span class="cm"> *     max = array[i]</span>
<span class="cm"> *</span>
<span class="cm"> * Finally, we prove that it is not possible to find an array position</span>
<span class="cm"> * such that the value stored at this position is greater than &#39;max&#39;.</span>
<span class="cm"> * If we can show this, we have proved that this algorithm indeed finds</span>
<span class="cm"> * a maximum value. Note that we prove that the algorithm finds an</span>
<span class="cm"> * arbitrary maximum (multiple maxima are possible), not necessarily</span>
<span class="cm"> * the first maximum.</span>
<span class="cm"> */</span>

<span class="kt">int</span>
<span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Btor</span> <span class="o">*</span><span class="n">btor</span><span class="p">;</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="o">*</span><span class="n">read</span><span class="p">,</span> <span class="o">*</span><span class="n">max</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">,</span> <span class="o">*</span><span class="n">ugt</span><span class="p">,</span> <span class="o">*</span><span class="n">formula</span><span class="p">,</span> <span class="o">*</span><span class="n">index</span><span class="p">;</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">indices</span><span class="p">[</span><span class="n">ARRAY1_EXAMPLE_ARRAY_SIZE</span><span class="p">];</span>
  <span class="n">BoolectorSort</span> <span class="n">sort_elem</span><span class="p">,</span> <span class="n">sort_index</span><span class="p">,</span> <span class="n">sort_array</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>

  <span class="n">btor</span>       <span class="o">=</span> <span class="n">boolector_new</span> <span class="p">();</span>
  <span class="n">sort_index</span> <span class="o">=</span> <span class="n">boolector_bitvec_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ARRAY1_EXAMPLE_INDEX_BW</span><span class="p">);</span>
  <span class="n">sort_elem</span>  <span class="o">=</span> <span class="n">boolector_bitvec_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ARRAY1_EXAMPLE_ELEM_BW</span><span class="p">);</span>
  <span class="n">sort_array</span> <span class="o">=</span> <span class="n">boolector_array_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_index</span><span class="p">,</span> <span class="n">sort_elem</span><span class="p">);</span>

  <span class="cm">/* We create all possible constants that are used as read indices */</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY1_EXAMPLE_ARRAY_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">boolector_int</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">sort_index</span><span class="p">);</span>

  <span class="n">array</span> <span class="o">=</span> <span class="n">boolector_array</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_array</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="cm">/* Current maximum is first element of array */</span>
  <span class="n">max</span> <span class="o">=</span> <span class="n">boolector_read</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="cm">/* Symbolic loop unrolling */</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY1_EXAMPLE_ARRAY_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">read</span> <span class="o">=</span> <span class="n">boolector_read</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">ugt</span>  <span class="o">=</span> <span class="n">boolector_ugt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">read</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
    <span class="cm">/* found a new maximum? */</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">boolector_cond</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ugt</span><span class="p">,</span> <span class="n">read</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
    <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
    <span class="n">max</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">read</span><span class="p">);</span>
    <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ugt</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/* Now we show that &#39;max&#39; is indeed a maximum */</span>
  <span class="cm">/* We read at an arbitrary position */</span>
  <span class="n">index</span> <span class="o">=</span> <span class="n">boolector_var</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_index</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">read</span>  <span class="o">=</span> <span class="n">boolector_read</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

  <span class="cm">/* We assume that it is possible that the read value is greater than &#39;max&#39; */</span>
  <span class="n">formula</span> <span class="o">=</span> <span class="n">boolector_ugt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">read</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>

  <span class="cm">/* We assert the formula and call Boolector */</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">formula</span><span class="p">);</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">boolector_sat</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Expect: unsat</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Boolector: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
          <span class="n">result</span> <span class="o">==</span> <span class="n">BOOLECTOR_SAT</span>
              <span class="o">?</span> <span class="s">&quot;sat&quot;</span>
              <span class="o">:</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">BOOLECTOR_UNSAT</span> <span class="o">?</span> <span class="s">&quot;unsat&quot;</span> <span class="o">:</span> <span class="s">&quot;unknown&quot;</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">BOOLECTOR_UNSAT</span><span class="p">)</span> <span class="n">abort</span> <span class="p">();</span>

  <span class="cm">/* clean up */</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY1_EXAMPLE_ARRAY_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">formula</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">read</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">array</span><span class="p">);</span>
  <span class="n">boolector_release_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_array</span><span class="p">);</span>
  <span class="n">boolector_release_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_index</span><span class="p">);</span>
  <span class="n">boolector_release_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_elem</span><span class="p">);</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">boolector_get_refs</span> <span class="p">(</span><span class="n">btor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">boolector_delete</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;boolector.h&quot;</span><span class="cp"></span>

<span class="cp">#define ARRAY2_EXAMPLE_ELEM_BW 8</span>
<span class="cp">#define ARRAY2_EXAMPLE_INDEX_BW 1</span>

<span class="cm">/* We demonstrate Boolector&#39;s ability to obtain Array models.</span>
<span class="cm"> * We check the following formula for satisfiability:</span>
<span class="cm"> * write (array1, 0, 3) = write (array2, 1, 5)</span>
<span class="cm"> */</span>

<span class="kt">int</span>
<span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Btor</span> <span class="o">*</span><span class="n">btor</span><span class="p">;</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">array1</span><span class="p">,</span> <span class="o">*</span><span class="n">array2</span><span class="p">,</span> <span class="o">*</span><span class="n">zero</span><span class="p">,</span> <span class="o">*</span><span class="n">one</span><span class="p">,</span> <span class="o">*</span><span class="n">val1</span><span class="p">,</span> <span class="o">*</span><span class="n">val2</span><span class="p">;</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">write1</span><span class="p">,</span> <span class="o">*</span><span class="n">write2</span><span class="p">,</span> <span class="o">*</span><span class="n">formula</span><span class="p">;</span>
  <span class="n">BoolectorSort</span> <span class="n">sort_index</span><span class="p">,</span> <span class="n">sort_elem</span><span class="p">,</span> <span class="n">sort_array</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">**</span><span class="n">indices</span><span class="p">,</span> <span class="o">**</span><span class="n">values</span><span class="p">;</span>
  <span class="kt">int32_t</span> <span class="n">result</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

  <span class="n">btor</span>       <span class="o">=</span> <span class="n">boolector_new</span> <span class="p">();</span>
  <span class="n">boolector_set_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">BTOR_OPT_OUTPUT_NUMBER_FORMAT</span><span class="p">,</span> <span class="n">BTOR_OUTPUT_BASE_HEX</span><span class="p">);</span>

  <span class="n">sort_index</span> <span class="o">=</span> <span class="n">boolector_bitvec_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ARRAY2_EXAMPLE_INDEX_BW</span><span class="p">);</span>
  <span class="n">sort_elem</span>  <span class="o">=</span> <span class="n">boolector_bitvec_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ARRAY2_EXAMPLE_ELEM_BW</span><span class="p">);</span>
  <span class="n">sort_array</span> <span class="o">=</span> <span class="n">boolector_array_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_index</span><span class="p">,</span> <span class="n">sort_elem</span><span class="p">);</span>
  <span class="n">boolector_set_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">BTOR_OPT_MODEL_GEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="n">zero</span>   <span class="o">=</span> <span class="n">boolector_zero</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_index</span><span class="p">);</span>
  <span class="n">one</span>    <span class="o">=</span> <span class="n">boolector_one</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_index</span><span class="p">);</span>
  <span class="n">val1</span>   <span class="o">=</span> <span class="n">boolector_int</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">sort_elem</span><span class="p">);</span>
  <span class="n">val2</span>   <span class="o">=</span> <span class="n">boolector_int</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">sort_elem</span><span class="p">);</span>
  <span class="n">array1</span> <span class="o">=</span> <span class="n">boolector_array</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_array</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">array2</span> <span class="o">=</span> <span class="n">boolector_array</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_array</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">write1</span> <span class="o">=</span> <span class="n">boolector_write</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">array1</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">val1</span><span class="p">);</span>
  <span class="n">write2</span> <span class="o">=</span> <span class="n">boolector_write</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">array2</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>
  <span class="cm">/* Note: we compare two arrays for equality ---&gt; needs extensional theory */</span>
  <span class="n">formula</span> <span class="o">=</span> <span class="n">boolector_eq</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">write1</span><span class="p">,</span> <span class="n">write2</span><span class="p">);</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">formula</span><span class="p">);</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">boolector_sat</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Expect: sat</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Boolector: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
          <span class="n">result</span> <span class="o">==</span> <span class="n">BOOLECTOR_SAT</span>
              <span class="o">?</span> <span class="s">&quot;sat&quot;</span>
              <span class="o">:</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">BOOLECTOR_UNSAT</span> <span class="o">?</span> <span class="s">&quot;unsat&quot;</span> <span class="o">:</span> <span class="s">&quot;unknown&quot;</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">BOOLECTOR_SAT</span><span class="p">)</span> <span class="n">abort</span> <span class="p">();</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Model:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="cm">/* Formula is satisfiable, we can obtain array models: */</span>
  <span class="n">boolector_array_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">array1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">indices</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Array1:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Array1[#x%s] = #x%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">boolector_free_array_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">boolector_array_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">array2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">indices</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Array2:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Array2[#x%s] = #x%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">boolector_free_array_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">boolector_array_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">write1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">indices</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Write1:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Write1[#x%s] = #x%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">boolector_free_array_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">boolector_array_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">write2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">indices</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Write2:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Write2[#x%s] = #x%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">boolector_free_array_assignment</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/* clean up */</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">formula</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">write1</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">write2</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">array1</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">array2</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">val1</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">zero</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">one</span><span class="p">);</span>
  <span class="n">boolector_release_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_array</span><span class="p">);</span>
  <span class="n">boolector_release_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_index</span><span class="p">);</span>
  <span class="n">boolector_release_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_elem</span><span class="p">);</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">boolector_get_refs</span> <span class="p">(</span><span class="n">btor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">boolector_delete</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;boolector.h&quot;</span><span class="cp"></span>

<span class="cp">#define ARRAY3_EXAMPLE_ELEM_BW 8</span>
<span class="cp">#define ARRAY3_EXAMPLE_INDEX_BW 1</span>

<span class="kt">int</span>
<span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
  <span class="n">BoolectorNode</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="o">*</span><span class="n">index1</span><span class="p">,</span> <span class="o">*</span><span class="n">index2</span><span class="p">,</span> <span class="o">*</span><span class="n">read1</span><span class="p">,</span> <span class="o">*</span><span class="n">read2</span><span class="p">,</span> <span class="o">*</span><span class="n">eq</span><span class="p">,</span> <span class="o">*</span><span class="n">ne</span><span class="p">;</span>
  <span class="n">BoolectorSort</span> <span class="n">sort_index</span><span class="p">,</span> <span class="n">sort_elem</span><span class="p">,</span> <span class="n">sort_array</span><span class="p">;</span>
  <span class="n">Btor</span> <span class="o">*</span><span class="n">btor</span><span class="p">;</span>

  <span class="n">btor</span>       <span class="o">=</span> <span class="n">boolector_new</span> <span class="p">();</span>
  <span class="n">sort_index</span> <span class="o">=</span> <span class="n">boolector_bitvec_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ARRAY3_EXAMPLE_INDEX_BW</span><span class="p">);</span>
  <span class="n">sort_elem</span>  <span class="o">=</span> <span class="n">boolector_bitvec_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ARRAY3_EXAMPLE_ELEM_BW</span><span class="p">);</span>
  <span class="n">sort_array</span> <span class="o">=</span> <span class="n">boolector_array_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_index</span><span class="p">,</span> <span class="n">sort_elem</span><span class="p">);</span>
  <span class="n">boolector_set_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">BTOR_OPT_INCREMENTAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="n">array</span>  <span class="o">=</span> <span class="n">boolector_array</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_array</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">index1</span> <span class="o">=</span> <span class="n">boolector_var</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">index2</span> <span class="o">=</span> <span class="n">boolector_var</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">read1</span>  <span class="o">=</span> <span class="n">boolector_read</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">index1</span><span class="p">);</span>
  <span class="n">read2</span>  <span class="o">=</span> <span class="n">boolector_read</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">index2</span><span class="p">);</span>
  <span class="n">eq</span>     <span class="o">=</span> <span class="n">boolector_eq</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">);</span>
  <span class="n">ne</span>     <span class="o">=</span> <span class="n">boolector_ne</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">read1</span><span class="p">,</span> <span class="n">read2</span><span class="p">);</span>

  <span class="cm">/* we enforce that index1 is equal to index 2 */</span>
  <span class="n">boolector_assert</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">eq</span><span class="p">);</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">boolector_sat</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Expect: sat</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Boolector: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
          <span class="n">result</span> <span class="o">==</span> <span class="n">BOOLECTOR_SAT</span>
              <span class="o">?</span> <span class="s">&quot;sat&quot;</span>
              <span class="o">:</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">BOOLECTOR_UNSAT</span> <span class="o">?</span> <span class="s">&quot;unsat&quot;</span> <span class="o">:</span> <span class="s">&quot;unknown&quot;</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">BOOLECTOR_SAT</span><span class="p">)</span> <span class="n">abort</span> <span class="p">();</span>
  <span class="cm">/* now we additionally assume that the read values differ</span>
<span class="cm">   * the instance is now unsatasfiable as read congruence is violated */</span>
  <span class="n">boolector_assume</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ne</span><span class="p">);</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">boolector_sat</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">BOOLECTOR_UNSAT</span><span class="p">);</span>
  <span class="cm">/* after the SAT call the assumptions are gone</span>
<span class="cm">   * the instance is now satisfiable again */</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">boolector_sat</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Expect: sat</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Boolector: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
          <span class="n">result</span> <span class="o">==</span> <span class="n">BOOLECTOR_SAT</span>
              <span class="o">?</span> <span class="s">&quot;sat&quot;</span>
              <span class="o">:</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">BOOLECTOR_UNSAT</span> <span class="o">?</span> <span class="s">&quot;unsat&quot;</span> <span class="o">:</span> <span class="s">&quot;unknown&quot;</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">BOOLECTOR_SAT</span><span class="p">)</span> <span class="n">abort</span> <span class="p">();</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">array</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">index1</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">index2</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">read1</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">read2</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">eq</span><span class="p">);</span>
  <span class="n">boolector_release</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">ne</span><span class="p">);</span>
  <span class="n">boolector_release_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_array</span><span class="p">);</span>
  <span class="n">boolector_release_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_index</span><span class="p">);</span>
  <span class="n">boolector_release_sort</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">sort_elem</span><span class="p">);</span>
  <span class="n">boolector_delete</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="cboolector_index.html" class="btn btn-neutral float-right" title="C Interface" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to Boolector’s API documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, the authors of Boolector.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>